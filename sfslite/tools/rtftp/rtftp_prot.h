// -*-c++-*-
/* This file was automatically generated by rpcc. */

#ifndef __RPCC_RTFTP_PROT_H_INCLUDED__
#define __RPCC_RTFTP_PROT_H_INCLUDED__ 1

#include "xdrmisc.h"

enum rtftp_status_t {
  RTFTP_OK = 0,
  RTFTP_NOENT = 1,
  RTFTP_CORRUPT = 2,
  RTFTP_EOF = 3,
  RTFTP_EEXISTS = 4,
  RTFTP_EFS = 5,
  RTFTP_BEGIN = 6,
  RTFTP_ERR = 7,
  RTFTP_OUT_OF_SEQ = 8,
  RTFTP_INCOMPLETE = 9,
};
void *rtftp_status_t_alloc ();
bool_t xdr_rtftp_status_t (XDR *, void *);
RPC_ENUM_DECL (rtftp_status_t)
TYPE2STRUCT( , rtftp_status_t);

template<class T> inline bool
rpc_traverse (T &t, rtftp_status_t &obj, const char *field = NULL)
{
  u_int32_t val = obj;
  bool ret = true;
  rpc_enter_field (t, field);
  if (!rpc_traverse (t, val)) {
    ret = false;
  } else {
    obj = rtftp_status_t (val);
  }
  rpc_exit_field (t, field);
  return ret;
}

#define RTFTP_HASHSZ 20
#define CHUNKSZ 0x8000
#define MAGIC 0xbeef4989

typedef rpc_opaque<RTFTP_HASHSZ> rtftp_hash_t;
void *rtftp_hash_t_alloc ();
bool_t xdr_rtftp_hash_t (XDR *, void *);
RPC_TYPEDEF_DECL (rtftp_hash_t)

typedef rpc_str<RPC_INFINITY> rtftp_id_t;
void *rtftp_id_t_alloc ();
bool_t xdr_rtftp_id_t (XDR *, void *);
RPC_TYPEDEF_DECL (rtftp_id_t)

typedef rpc_bytes<RPC_INFINITY> rtftp_data_t;
void *rtftp_data_t_alloc ();
bool_t xdr_rtftp_data_t (XDR *, void *);
RPC_TYPEDEF_DECL (rtftp_data_t)

typedef int64_t rtftp_xfer_id_t;
void *rtftp_xfer_id_t_alloc ();
bool_t xdr_rtftp_xfer_id_t (XDR *, void *);
RPC_TYPEDEF_DECL (rtftp_xfer_id_t)


struct rtftp_file_t {
  u_int32_t magic;
  rtftp_id_t name;
  rtftp_hash_t hash;
  rtftp_data_t data;
};
void *rtftp_file_t_alloc ();
bool_t xdr_rtftp_file_t (XDR *, void *);
RPC_STRUCT_DECL (rtftp_file_t)

template<class T> bool
rpc_traverse (T &t, rtftp_file_t &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  ret = rpc_traverse (t, obj.magic, "magic")
    && rpc_traverse (t, obj.name, "name")
    && rpc_traverse (t, obj.hash, "hash")
    && rpc_traverse (t, obj.data, "data");
  rpc_exit_field (t, field);
  return ret;
}



struct rtftp_header_t {
  u_int32_t magic;
  rtftp_id_t name;
  rtftp_hash_t hash;
  u_int32_t size;
};
void *rtftp_header_t_alloc ();
bool_t xdr_rtftp_header_t (XDR *, void *);
RPC_STRUCT_DECL (rtftp_header_t)

template<class T> bool
rpc_traverse (T &t, rtftp_header_t &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  ret = rpc_traverse (t, obj.magic, "magic")
    && rpc_traverse (t, obj.name, "name")
    && rpc_traverse (t, obj.hash, "hash")
    && rpc_traverse (t, obj.size, "size");
  rpc_exit_field (t, field);
  return ret;
}



struct rtftp_xfer_header_t {
  rtftp_xfer_id_t xfer_id;
  u_int32_t size;
  rtftp_hash_t hash;
};
void *rtftp_xfer_header_t_alloc ();
bool_t xdr_rtftp_xfer_header_t (XDR *, void *);
RPC_STRUCT_DECL (rtftp_xfer_header_t)

template<class T> bool
rpc_traverse (T &t, rtftp_xfer_header_t &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  ret = rpc_traverse (t, obj.xfer_id, "xfer_id")
    && rpc_traverse (t, obj.size, "size")
    && rpc_traverse (t, obj.hash, "hash");
  rpc_exit_field (t, field);
  return ret;
}



struct rtftp_chunkid_t {
  rtftp_xfer_id_t xfer_id;
  u_int32_t offset;
  u_int32_t size;
};
void *rtftp_chunkid_t_alloc ();
bool_t xdr_rtftp_chunkid_t (XDR *, void *);
RPC_STRUCT_DECL (rtftp_chunkid_t)

template<class T> bool
rpc_traverse (T &t, rtftp_chunkid_t &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  ret = rpc_traverse (t, obj.xfer_id, "xfer_id")
    && rpc_traverse (t, obj.offset, "offset")
    && rpc_traverse (t, obj.size, "size");
  rpc_exit_field (t, field);
  return ret;
}



struct rtftp_chunk_t {
  rtftp_chunkid_t id;
  rtftp_data_t data;
};
void *rtftp_chunk_t_alloc ();
bool_t xdr_rtftp_chunk_t (XDR *, void *);
RPC_STRUCT_DECL (rtftp_chunk_t)

template<class T> bool
rpc_traverse (T &t, rtftp_chunk_t &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  ret = rpc_traverse (t, obj.id, "id")
    && rpc_traverse (t, obj.data, "data");
  rpc_exit_field (t, field);
  return ret;
}



struct rtftp_footer_t {
  rtftp_xfer_id_t xfer_id;
  u_int32_t size;
  u_int32_t n_chunks;
  rtftp_hash_t hash;
};
void *rtftp_footer_t_alloc ();
bool_t xdr_rtftp_footer_t (XDR *, void *);
RPC_STRUCT_DECL (rtftp_footer_t)

template<class T> bool
rpc_traverse (T &t, rtftp_footer_t &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  ret = rpc_traverse (t, obj.xfer_id, "xfer_id")
    && rpc_traverse (t, obj.size, "size")
    && rpc_traverse (t, obj.n_chunks, "n_chunks")
    && rpc_traverse (t, obj.hash, "hash");
  rpc_exit_field (t, field);
  return ret;
}



struct rtftp_get_res_t {
  const rtftp_status_t status;
  union {
    union_entry_base _base;
    union_entry<rtftp_file_t> file;
  };

#define rpcunion_tag_rtftp_get_res_t status
#define rpcunion_switch_rtftp_get_res_t(swarg, action, voidaction, defaction) \
  switch (swarg) { \
  case RTFTP_OK: \
    action (rtftp_file_t, file); \
    break; \
  default: \
    voidaction; \
    break; \
  }

  rtftp_get_res_t (rtftp_status_t _tag = (rtftp_status_t) 0) : status (_tag)
    { _base.init (); set_status (_tag); }
  rtftp_get_res_t (const rtftp_get_res_t &_s)
    : status (_s.status)
    { _base.init (_s._base); }
  ~rtftp_get_res_t () { _base.destroy (); }
  rtftp_get_res_t &operator= (const rtftp_get_res_t &_s) {
    const_cast<rtftp_status_t &> (status) = _s.status;
    _base.assign (_s._base);
    return *this;
  }

  void set_status (rtftp_status_t _tag) {
    const_cast<rtftp_status_t &> (status) = _tag;
    rpcunion_switch_rtftp_get_res_t
      (_tag, RPCUNION_SET, _base.destroy (), _base.destroy ());
  }
};

template<class T> bool
rpc_traverse (T &t, rtftp_get_res_t &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  rtftp_status_t tag = obj.status;
  if (!rpc_traverse (t, tag, "status")) { 
    ret = false;
  } else {
    if (tag != obj.status)
      obj.set_status (tag);

    rpcunion_switch_rtftp_get_res_t
      (obj.status, ret = RPCUNION_TRAVERSE_2, ret = true, ret = false);
    /* gcc 4.0.3 makes buggy warnings without the following.. */
  }
  rpc_exit_field (t, field);
  return ret;
}
inline bool
rpc_traverse (const stompcast_t &s, rtftp_get_res_t &obj, const char *field = NULL)
{
  rpcunion_switch_rtftp_get_res_t
    (obj.status, RPCUNION_REC_STOMPCAST,
     obj._base.destroy (); return true, obj._base.destroy (); return true;);
  /* gcc 4.0.3 makes buggy warnings without the following line */
  return false;
}
void *rtftp_get_res_t_alloc ();
bool_t xdr_rtftp_get_res_t (XDR *, void *);
RPC_UNION_DECL (rtftp_get_res_t)



struct rtftp_put2_res_t {
  const rtftp_status_t status;
  union {
    union_entry_base _base;
    union_entry<rtftp_xfer_id_t> xfer_id;
  };

#define rpcunion_tag_rtftp_put2_res_t status
#define rpcunion_switch_rtftp_put2_res_t(swarg, action, voidaction, defaction) \
  switch (swarg) { \
  case RTFTP_BEGIN: \
    action (rtftp_xfer_id_t, xfer_id); \
    break; \
  default: \
    voidaction; \
    break; \
  }

  rtftp_put2_res_t (rtftp_status_t _tag = (rtftp_status_t) 0) : status (_tag)
    { _base.init (); set_status (_tag); }
  rtftp_put2_res_t (const rtftp_put2_res_t &_s)
    : status (_s.status)
    { _base.init (_s._base); }
  ~rtftp_put2_res_t () { _base.destroy (); }
  rtftp_put2_res_t &operator= (const rtftp_put2_res_t &_s) {
    const_cast<rtftp_status_t &> (status) = _s.status;
    _base.assign (_s._base);
    return *this;
  }

  void set_status (rtftp_status_t _tag) {
    const_cast<rtftp_status_t &> (status) = _tag;
    rpcunion_switch_rtftp_put2_res_t
      (_tag, RPCUNION_SET, _base.destroy (), _base.destroy ());
  }
};

template<class T> bool
rpc_traverse (T &t, rtftp_put2_res_t &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  rtftp_status_t tag = obj.status;
  if (!rpc_traverse (t, tag, "status")) { 
    ret = false;
  } else {
    if (tag != obj.status)
      obj.set_status (tag);

    rpcunion_switch_rtftp_put2_res_t
      (obj.status, ret = RPCUNION_TRAVERSE_2, ret = true, ret = false);
    /* gcc 4.0.3 makes buggy warnings without the following.. */
  }
  rpc_exit_field (t, field);
  return ret;
}
inline bool
rpc_traverse (const stompcast_t &s, rtftp_put2_res_t &obj, const char *field = NULL)
{
  rpcunion_switch_rtftp_put2_res_t
    (obj.status, RPCUNION_REC_STOMPCAST,
     obj._base.destroy (); return true, obj._base.destroy (); return true;);
  /* gcc 4.0.3 makes buggy warnings without the following line */
  return false;
}
void *rtftp_put2_res_t_alloc ();
bool_t xdr_rtftp_put2_res_t (XDR *, void *);
RPC_UNION_DECL (rtftp_put2_res_t)



struct rtftp_put2_arg_t {
  const rtftp_status_t status;
  union {
    union_entry_base _base;
    union_entry<rtftp_id_t> name;
    union_entry<rtftp_chunk_t> data;
    union_entry<rtftp_footer_t> footer;
  };

#define rpcunion_tag_rtftp_put2_arg_t status
#define rpcunion_switch_rtftp_put2_arg_t(swarg, action, voidaction, defaction) \
  switch (swarg) { \
  case RTFTP_BEGIN: \
    action (rtftp_id_t, name); \
    break; \
  case RTFTP_OK: \
    action (rtftp_chunk_t, data); \
    break; \
  case RTFTP_EOF: \
    action (rtftp_footer_t, footer); \
    break; \
  default: \
    voidaction; \
    break; \
  }

  rtftp_put2_arg_t (rtftp_status_t _tag = (rtftp_status_t) 0) : status (_tag)
    { _base.init (); set_status (_tag); }
  rtftp_put2_arg_t (const rtftp_put2_arg_t &_s)
    : status (_s.status)
    { _base.init (_s._base); }
  ~rtftp_put2_arg_t () { _base.destroy (); }
  rtftp_put2_arg_t &operator= (const rtftp_put2_arg_t &_s) {
    const_cast<rtftp_status_t &> (status) = _s.status;
    _base.assign (_s._base);
    return *this;
  }

  void set_status (rtftp_status_t _tag) {
    const_cast<rtftp_status_t &> (status) = _tag;
    rpcunion_switch_rtftp_put2_arg_t
      (_tag, RPCUNION_SET, _base.destroy (), _base.destroy ());
  }
};

template<class T> bool
rpc_traverse (T &t, rtftp_put2_arg_t &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  rtftp_status_t tag = obj.status;
  if (!rpc_traverse (t, tag, "status")) { 
    ret = false;
  } else {
    if (tag != obj.status)
      obj.set_status (tag);

    rpcunion_switch_rtftp_put2_arg_t
      (obj.status, ret = RPCUNION_TRAVERSE_2, ret = true, ret = false);
    /* gcc 4.0.3 makes buggy warnings without the following.. */
  }
  rpc_exit_field (t, field);
  return ret;
}
inline bool
rpc_traverse (const stompcast_t &s, rtftp_put2_arg_t &obj, const char *field = NULL)
{
  rpcunion_switch_rtftp_put2_arg_t
    (obj.status, RPCUNION_REC_STOMPCAST,
     obj._base.destroy (); return true, obj._base.destroy (); return true;);
  /* gcc 4.0.3 makes buggy warnings without the following line */
  return false;
}
void *rtftp_put2_arg_t_alloc ();
bool_t xdr_rtftp_put2_arg_t (XDR *, void *);
RPC_UNION_DECL (rtftp_put2_arg_t)



struct rtftp_get2_arg_t {
  const rtftp_status_t status;
  union {
    union_entry_base _base;
    union_entry<rtftp_id_t> name;
    union_entry<rtftp_chunkid_t> chunk;
    union_entry<rtftp_xfer_id_t> id;
  };

#define rpcunion_tag_rtftp_get2_arg_t status
#define rpcunion_switch_rtftp_get2_arg_t(swarg, action, voidaction, defaction) \
  switch (swarg) { \
  case RTFTP_BEGIN: \
    action (rtftp_id_t, name); \
    break; \
  case RTFTP_OK: \
    action (rtftp_chunkid_t, chunk); \
    break; \
  case RTFTP_EOF: \
    action (rtftp_xfer_id_t, id); \
    break; \
  default: \
    voidaction; \
    break; \
  }

  rtftp_get2_arg_t (rtftp_status_t _tag = (rtftp_status_t) 0) : status (_tag)
    { _base.init (); set_status (_tag); }
  rtftp_get2_arg_t (const rtftp_get2_arg_t &_s)
    : status (_s.status)
    { _base.init (_s._base); }
  ~rtftp_get2_arg_t () { _base.destroy (); }
  rtftp_get2_arg_t &operator= (const rtftp_get2_arg_t &_s) {
    const_cast<rtftp_status_t &> (status) = _s.status;
    _base.assign (_s._base);
    return *this;
  }

  void set_status (rtftp_status_t _tag) {
    const_cast<rtftp_status_t &> (status) = _tag;
    rpcunion_switch_rtftp_get2_arg_t
      (_tag, RPCUNION_SET, _base.destroy (), _base.destroy ());
  }
};

template<class T> bool
rpc_traverse (T &t, rtftp_get2_arg_t &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  rtftp_status_t tag = obj.status;
  if (!rpc_traverse (t, tag, "status")) { 
    ret = false;
  } else {
    if (tag != obj.status)
      obj.set_status (tag);

    rpcunion_switch_rtftp_get2_arg_t
      (obj.status, ret = RPCUNION_TRAVERSE_2, ret = true, ret = false);
    /* gcc 4.0.3 makes buggy warnings without the following.. */
  }
  rpc_exit_field (t, field);
  return ret;
}
inline bool
rpc_traverse (const stompcast_t &s, rtftp_get2_arg_t &obj, const char *field = NULL)
{
  rpcunion_switch_rtftp_get2_arg_t
    (obj.status, RPCUNION_REC_STOMPCAST,
     obj._base.destroy (); return true, obj._base.destroy (); return true;);
  /* gcc 4.0.3 makes buggy warnings without the following line */
  return false;
}
void *rtftp_get2_arg_t_alloc ();
bool_t xdr_rtftp_get2_arg_t (XDR *, void *);
RPC_UNION_DECL (rtftp_get2_arg_t)



struct rtftp_get2_res_t {
  const rtftp_status_t status;
  union {
    union_entry_base _base;
    union_entry<rtftp_xfer_header_t> header;
    union_entry<rtftp_chunk_t> chunk;
  };

#define rpcunion_tag_rtftp_get2_res_t status
#define rpcunion_switch_rtftp_get2_res_t(swarg, action, voidaction, defaction) \
  switch (swarg) { \
  case RTFTP_BEGIN: \
    action (rtftp_xfer_header_t, header); \
    break; \
  case RTFTP_OK: \
    action (rtftp_chunk_t, chunk); \
    break; \
  default: \
    voidaction; \
    break; \
  }

  rtftp_get2_res_t (rtftp_status_t _tag = (rtftp_status_t) 0) : status (_tag)
    { _base.init (); set_status (_tag); }
  rtftp_get2_res_t (const rtftp_get2_res_t &_s)
    : status (_s.status)
    { _base.init (_s._base); }
  ~rtftp_get2_res_t () { _base.destroy (); }
  rtftp_get2_res_t &operator= (const rtftp_get2_res_t &_s) {
    const_cast<rtftp_status_t &> (status) = _s.status;
    _base.assign (_s._base);
    return *this;
  }

  void set_status (rtftp_status_t _tag) {
    const_cast<rtftp_status_t &> (status) = _tag;
    rpcunion_switch_rtftp_get2_res_t
      (_tag, RPCUNION_SET, _base.destroy (), _base.destroy ());
  }
};

template<class T> bool
rpc_traverse (T &t, rtftp_get2_res_t &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  rtftp_status_t tag = obj.status;
  if (!rpc_traverse (t, tag, "status")) { 
    ret = false;
  } else {
    if (tag != obj.status)
      obj.set_status (tag);

    rpcunion_switch_rtftp_get2_res_t
      (obj.status, ret = RPCUNION_TRAVERSE_2, ret = true, ret = false);
    /* gcc 4.0.3 makes buggy warnings without the following.. */
  }
  rpc_exit_field (t, field);
  return ret;
}
inline bool
rpc_traverse (const stompcast_t &s, rtftp_get2_res_t &obj, const char *field = NULL)
{
  rpcunion_switch_rtftp_get2_res_t
    (obj.status, RPCUNION_REC_STOMPCAST,
     obj._base.destroy (); return true, obj._base.destroy (); return true;);
  /* gcc 4.0.3 makes buggy warnings without the following line */
  return false;
}
void *rtftp_get2_res_t_alloc ();
bool_t xdr_rtftp_get2_res_t (XDR *, void *);
RPC_UNION_DECL (rtftp_get2_res_t)


#ifndef RTFTP_PROGRAM
#define RTFTP_PROGRAM 5401
#endif /* !RTFTP_PROGRAM */
extern const rpc_program rtftp_program_1;
enum { RTFTP_VERS = 1 };
enum {
  RTFTP_NULL = 0,
  RTFTP_CHECK = 1,
  RTFTP_PUT = 2,
  RTFTP_GET = 3,
  RTFTP_PUT2 = 4,
  RTFTP_GET2 = 5,
};
#define RTFTP_PROGRAM_1_APPLY_NOVOID(macro, void) \
  macro (RTFTP_NULL, void, void) \
  macro (RTFTP_CHECK, rtftp_id_t, rtftp_status_t) \
  macro (RTFTP_PUT, rtftp_file_t, rtftp_status_t) \
  macro (RTFTP_GET, rtftp_id_t, rtftp_get_res_t) \
  macro (RTFTP_PUT2, rtftp_put2_arg_t, rtftp_put2_res_t) \
  macro (RTFTP_GET2, rtftp_get2_arg_t, rtftp_get2_res_t)
#define RTFTP_PROGRAM_1_APPLY(macro) \
  RTFTP_PROGRAM_1_APPLY_NOVOID(macro, void)

namespace RPC {
  namespace rtftp_program_1 {

    // RTFTP_NULL -----------------------------------------

    template<class C, class E> void
    rtftp_null(C c, E cb)
    { c->call (RTFTP_NULL, NULL, NULL, cb); }

    template<class E> void
    w_rtftp_null(typename callback<void,rpc_bundle_t,E>::ref c, E cb)
    { (*c) ( rpc_bundle_t (RTFTP_NULL, NULL, NULL), cb); }

    template<class R, class E> R
    w_rtftp_null(typename callback<R,rpc_bundle_t,E>::ref c, E cb)
    { return (*c) ( rpc_bundle_t (RTFTP_NULL, NULL, NULL), cb); }

    template<class S>
    class rtftp_null_srv_t {
    public:
      rtftp_null_srv_t(S *s) : _replied (false), _sbp (s) {}
      void reply () { check_reply (); _sbp->reply (NULL); }
      S *sbp () { return _sbp; }
      const S *sbp () const { return _sbp; }
      void reject (auth_stat s) { check_reply (); _sbp->reject (s); }
      void reject (accept_stat s) { check_reply (); _sbp->reject (s); }
      void reject () { check_reply (); _sbp->reject (); }

      typedef void arg_ty;

      typedef void res_ty;

      template<class C, class E> void
      call_full(C c, const void *arg, void *res, E cb)
      { c->call (RTFTP_NULL, arg, res, cb); }

      template<class C, class E>
      void call(C c,  E cb)
      { rtftp_null(c,  cb); }

    private:
      void check_reply () { assert (!_replied); _replied = true; }
      bool _replied;
      S *_sbp;
    };


    // RTFTP_CHECK -----------------------------------------

    template<class C, class E> void
    rtftp_check(C c, const rtftp_id_t *arg, rtftp_status_t *res, E cb)
    { c->call (RTFTP_CHECK, arg, res, cb); }

    template<class C, class E> void
    rtftp_check(C c, const rtftp_id_t &arg, rtftp_status_t *res, E cb)
    { c->call (RTFTP_CHECK, &arg, res, cb); }

    template<class E> void
    w_rtftp_check(typename callback<void,rpc_bundle_t,E>::ref c, const rtftp_id_t *arg, rtftp_status_t *res, E cb)
    { (*c) ( rpc_bundle_t (RTFTP_CHECK, arg, res), cb); }

    template<class E> void
    w_rtftp_check(typename callback<void,rpc_bundle_t,E>::ref c, const rtftp_id_t &arg, rtftp_status_t *res, E cb)
    { (*c) ( rpc_bundle_t (RTFTP_CHECK, &arg, res), cb); }

    template<class R, class E> R
    w_rtftp_check(typename callback<R,rpc_bundle_t,E>::ref c, const rtftp_id_t *arg, rtftp_status_t *res, E cb)
    { return (*c) ( rpc_bundle_t (RTFTP_CHECK, arg, res), cb); }

    template<class R, class E> R
    w_rtftp_check(typename callback<R,rpc_bundle_t,E>::ref c, const rtftp_id_t &arg, rtftp_status_t *res, E cb)
    { return (*c) ( rpc_bundle_t (RTFTP_CHECK, &arg, res), cb); }

    template<class S>
    class rtftp_check_srv_t {
    public:
      rtftp_check_srv_t(S *s) : _replied (false), _sbp (s) {}
      const ::rtftp_id_t* getarg() const {  return static_cast<rtftp_id_t*> (_sbp->getvoidarg ()); }
      ::rtftp_id_t* getarg() {  return static_cast<rtftp_id_t*> (_sbp->getvoidarg ()); }
      void reply (const ::rtftp_status_t *r) { check_reply (); _sbp->reply (r); }
      void reply (const ::rtftp_status_t &r) { check_reply (); _sbp->replyref (r); }
      void reply (ptr< ::rtftp_status_t> r) { check_reply (); _sbp->reply (r); }
      ptr<rtftp_status_t> alloc_res ()  { return New refcounted<rtftp_status_t> (); }
      template<class T> ptr<rtftp_status_t>
      alloc_res (const T &t)  { return New refcounted<rtftp_status_t> (t); }
      S *sbp () { return _sbp; }
      const S *sbp () const { return _sbp; }
      void reject (auth_stat s) { check_reply (); _sbp->reject (s); }
      void reject (accept_stat s) { check_reply (); _sbp->reject (s); }
      void reject () { check_reply (); _sbp->reject (); }

      typedef rtftp_id_t arg_ty;

      typedef rtftp_status_t res_ty;

      template<class C, class E> void
      call_full(C c, const rtftp_id_t *arg, rtftp_status_t *res, E cb)
      { c->call (RTFTP_CHECK, arg, res, cb); }

      template<class C, class E>
      void call(C c, const rtftp_id_t* arg, rtftp_status_t* res, E cb)
      { rtftp_check(c, arg, res, cb); }

    private:
      void check_reply () { assert (!_replied); _replied = true; }
      bool _replied;
      S *_sbp;
    };


    // RTFTP_PUT -----------------------------------------

    template<class C, class E> void
    rtftp_put(C c, const rtftp_file_t *arg, rtftp_status_t *res, E cb)
    { c->call (RTFTP_PUT, arg, res, cb); }

    template<class C, class E> void
    rtftp_put(C c, const rtftp_file_t &arg, rtftp_status_t *res, E cb)
    { c->call (RTFTP_PUT, &arg, res, cb); }

    template<class E> void
    w_rtftp_put(typename callback<void,rpc_bundle_t,E>::ref c, const rtftp_file_t *arg, rtftp_status_t *res, E cb)
    { (*c) ( rpc_bundle_t (RTFTP_PUT, arg, res), cb); }

    template<class E> void
    w_rtftp_put(typename callback<void,rpc_bundle_t,E>::ref c, const rtftp_file_t &arg, rtftp_status_t *res, E cb)
    { (*c) ( rpc_bundle_t (RTFTP_PUT, &arg, res), cb); }

    template<class R, class E> R
    w_rtftp_put(typename callback<R,rpc_bundle_t,E>::ref c, const rtftp_file_t *arg, rtftp_status_t *res, E cb)
    { return (*c) ( rpc_bundle_t (RTFTP_PUT, arg, res), cb); }

    template<class R, class E> R
    w_rtftp_put(typename callback<R,rpc_bundle_t,E>::ref c, const rtftp_file_t &arg, rtftp_status_t *res, E cb)
    { return (*c) ( rpc_bundle_t (RTFTP_PUT, &arg, res), cb); }

    template<class S>
    class rtftp_put_srv_t {
    public:
      rtftp_put_srv_t(S *s) : _replied (false), _sbp (s) {}
      const ::rtftp_file_t* getarg() const {  return static_cast<rtftp_file_t*> (_sbp->getvoidarg ()); }
      ::rtftp_file_t* getarg() {  return static_cast<rtftp_file_t*> (_sbp->getvoidarg ()); }
      void reply (const ::rtftp_status_t *r) { check_reply (); _sbp->reply (r); }
      void reply (const ::rtftp_status_t &r) { check_reply (); _sbp->replyref (r); }
      void reply (ptr< ::rtftp_status_t> r) { check_reply (); _sbp->reply (r); }
      ptr<rtftp_status_t> alloc_res ()  { return New refcounted<rtftp_status_t> (); }
      template<class T> ptr<rtftp_status_t>
      alloc_res (const T &t)  { return New refcounted<rtftp_status_t> (t); }
      S *sbp () { return _sbp; }
      const S *sbp () const { return _sbp; }
      void reject (auth_stat s) { check_reply (); _sbp->reject (s); }
      void reject (accept_stat s) { check_reply (); _sbp->reject (s); }
      void reject () { check_reply (); _sbp->reject (); }

      typedef rtftp_file_t arg_ty;

      typedef rtftp_status_t res_ty;

      template<class C, class E> void
      call_full(C c, const rtftp_file_t *arg, rtftp_status_t *res, E cb)
      { c->call (RTFTP_PUT, arg, res, cb); }

      template<class C, class E>
      void call(C c, const rtftp_file_t* arg, rtftp_status_t* res, E cb)
      { rtftp_put(c, arg, res, cb); }

    private:
      void check_reply () { assert (!_replied); _replied = true; }
      bool _replied;
      S *_sbp;
    };


    // RTFTP_GET -----------------------------------------

    template<class C, class E> void
    rtftp_get(C c, const rtftp_id_t *arg, rtftp_get_res_t *res, E cb)
    { c->call (RTFTP_GET, arg, res, cb); }

    template<class C, class E> void
    rtftp_get(C c, const rtftp_id_t &arg, rtftp_get_res_t *res, E cb)
    { c->call (RTFTP_GET, &arg, res, cb); }

    template<class E> void
    w_rtftp_get(typename callback<void,rpc_bundle_t,E>::ref c, const rtftp_id_t *arg, rtftp_get_res_t *res, E cb)
    { (*c) ( rpc_bundle_t (RTFTP_GET, arg, res), cb); }

    template<class E> void
    w_rtftp_get(typename callback<void,rpc_bundle_t,E>::ref c, const rtftp_id_t &arg, rtftp_get_res_t *res, E cb)
    { (*c) ( rpc_bundle_t (RTFTP_GET, &arg, res), cb); }

    template<class R, class E> R
    w_rtftp_get(typename callback<R,rpc_bundle_t,E>::ref c, const rtftp_id_t *arg, rtftp_get_res_t *res, E cb)
    { return (*c) ( rpc_bundle_t (RTFTP_GET, arg, res), cb); }

    template<class R, class E> R
    w_rtftp_get(typename callback<R,rpc_bundle_t,E>::ref c, const rtftp_id_t &arg, rtftp_get_res_t *res, E cb)
    { return (*c) ( rpc_bundle_t (RTFTP_GET, &arg, res), cb); }

    template<class S>
    class rtftp_get_srv_t {
    public:
      rtftp_get_srv_t(S *s) : _replied (false), _sbp (s) {}
      const ::rtftp_id_t* getarg() const {  return static_cast<rtftp_id_t*> (_sbp->getvoidarg ()); }
      ::rtftp_id_t* getarg() {  return static_cast<rtftp_id_t*> (_sbp->getvoidarg ()); }
      void reply (const ::rtftp_get_res_t *r) { check_reply (); _sbp->reply (r); }
      void reply (const ::rtftp_get_res_t &r) { check_reply (); _sbp->replyref (r); }
      void reply (ptr< ::rtftp_get_res_t> r) { check_reply (); _sbp->reply (r); }
      ptr<rtftp_get_res_t> alloc_res ()  { return New refcounted<rtftp_get_res_t> (); }
      template<class T> ptr<rtftp_get_res_t>
      alloc_res (const T &t)  { return New refcounted<rtftp_get_res_t> (t); }
      S *sbp () { return _sbp; }
      const S *sbp () const { return _sbp; }
      void reject (auth_stat s) { check_reply (); _sbp->reject (s); }
      void reject (accept_stat s) { check_reply (); _sbp->reject (s); }
      void reject () { check_reply (); _sbp->reject (); }

      typedef rtftp_id_t arg_ty;

      typedef rtftp_get_res_t res_ty;

      template<class C, class E> void
      call_full(C c, const rtftp_id_t *arg, rtftp_get_res_t *res, E cb)
      { c->call (RTFTP_GET, arg, res, cb); }

      template<class C, class E>
      void call(C c, const rtftp_id_t* arg, rtftp_get_res_t* res, E cb)
      { rtftp_get(c, arg, res, cb); }

    private:
      void check_reply () { assert (!_replied); _replied = true; }
      bool _replied;
      S *_sbp;
    };


    // RTFTP_PUT2 -----------------------------------------

    template<class C, class E> void
    rtftp_put2(C c, const rtftp_put2_arg_t *arg, rtftp_put2_res_t *res, E cb)
    { c->call (RTFTP_PUT2, arg, res, cb); }

    template<class C, class E> void
    rtftp_put2(C c, const rtftp_put2_arg_t &arg, rtftp_put2_res_t *res, E cb)
    { c->call (RTFTP_PUT2, &arg, res, cb); }

    template<class E> void
    w_rtftp_put2(typename callback<void,rpc_bundle_t,E>::ref c, const rtftp_put2_arg_t *arg, rtftp_put2_res_t *res, E cb)
    { (*c) ( rpc_bundle_t (RTFTP_PUT2, arg, res), cb); }

    template<class E> void
    w_rtftp_put2(typename callback<void,rpc_bundle_t,E>::ref c, const rtftp_put2_arg_t &arg, rtftp_put2_res_t *res, E cb)
    { (*c) ( rpc_bundle_t (RTFTP_PUT2, &arg, res), cb); }

    template<class R, class E> R
    w_rtftp_put2(typename callback<R,rpc_bundle_t,E>::ref c, const rtftp_put2_arg_t *arg, rtftp_put2_res_t *res, E cb)
    { return (*c) ( rpc_bundle_t (RTFTP_PUT2, arg, res), cb); }

    template<class R, class E> R
    w_rtftp_put2(typename callback<R,rpc_bundle_t,E>::ref c, const rtftp_put2_arg_t &arg, rtftp_put2_res_t *res, E cb)
    { return (*c) ( rpc_bundle_t (RTFTP_PUT2, &arg, res), cb); }

    template<class S>
    class rtftp_put2_srv_t {
    public:
      rtftp_put2_srv_t(S *s) : _replied (false), _sbp (s) {}
      const ::rtftp_put2_arg_t* getarg() const {  return static_cast<rtftp_put2_arg_t*> (_sbp->getvoidarg ()); }
      ::rtftp_put2_arg_t* getarg() {  return static_cast<rtftp_put2_arg_t*> (_sbp->getvoidarg ()); }
      void reply (const ::rtftp_put2_res_t *r) { check_reply (); _sbp->reply (r); }
      void reply (const ::rtftp_put2_res_t &r) { check_reply (); _sbp->replyref (r); }
      void reply (ptr< ::rtftp_put2_res_t> r) { check_reply (); _sbp->reply (r); }
      ptr<rtftp_put2_res_t> alloc_res ()  { return New refcounted<rtftp_put2_res_t> (); }
      template<class T> ptr<rtftp_put2_res_t>
      alloc_res (const T &t)  { return New refcounted<rtftp_put2_res_t> (t); }
      S *sbp () { return _sbp; }
      const S *sbp () const { return _sbp; }
      void reject (auth_stat s) { check_reply (); _sbp->reject (s); }
      void reject (accept_stat s) { check_reply (); _sbp->reject (s); }
      void reject () { check_reply (); _sbp->reject (); }

      typedef rtftp_put2_arg_t arg_ty;

      typedef rtftp_put2_res_t res_ty;

      template<class C, class E> void
      call_full(C c, const rtftp_put2_arg_t *arg, rtftp_put2_res_t *res, E cb)
      { c->call (RTFTP_PUT2, arg, res, cb); }

      template<class C, class E>
      void call(C c, const rtftp_put2_arg_t* arg, rtftp_put2_res_t* res, E cb)
      { rtftp_put2(c, arg, res, cb); }

    private:
      void check_reply () { assert (!_replied); _replied = true; }
      bool _replied;
      S *_sbp;
    };


    // RTFTP_GET2 -----------------------------------------

    template<class C, class E> void
    rtftp_get2(C c, const rtftp_get2_arg_t *arg, rtftp_get2_res_t *res, E cb)
    { c->call (RTFTP_GET2, arg, res, cb); }

    template<class C, class E> void
    rtftp_get2(C c, const rtftp_get2_arg_t &arg, rtftp_get2_res_t *res, E cb)
    { c->call (RTFTP_GET2, &arg, res, cb); }

    template<class E> void
    w_rtftp_get2(typename callback<void,rpc_bundle_t,E>::ref c, const rtftp_get2_arg_t *arg, rtftp_get2_res_t *res, E cb)
    { (*c) ( rpc_bundle_t (RTFTP_GET2, arg, res), cb); }

    template<class E> void
    w_rtftp_get2(typename callback<void,rpc_bundle_t,E>::ref c, const rtftp_get2_arg_t &arg, rtftp_get2_res_t *res, E cb)
    { (*c) ( rpc_bundle_t (RTFTP_GET2, &arg, res), cb); }

    template<class R, class E> R
    w_rtftp_get2(typename callback<R,rpc_bundle_t,E>::ref c, const rtftp_get2_arg_t *arg, rtftp_get2_res_t *res, E cb)
    { return (*c) ( rpc_bundle_t (RTFTP_GET2, arg, res), cb); }

    template<class R, class E> R
    w_rtftp_get2(typename callback<R,rpc_bundle_t,E>::ref c, const rtftp_get2_arg_t &arg, rtftp_get2_res_t *res, E cb)
    { return (*c) ( rpc_bundle_t (RTFTP_GET2, &arg, res), cb); }

    template<class S>
    class rtftp_get2_srv_t {
    public:
      rtftp_get2_srv_t(S *s) : _replied (false), _sbp (s) {}
      const ::rtftp_get2_arg_t* getarg() const {  return static_cast<rtftp_get2_arg_t*> (_sbp->getvoidarg ()); }
      ::rtftp_get2_arg_t* getarg() {  return static_cast<rtftp_get2_arg_t*> (_sbp->getvoidarg ()); }
      void reply (const ::rtftp_get2_res_t *r) { check_reply (); _sbp->reply (r); }
      void reply (const ::rtftp_get2_res_t &r) { check_reply (); _sbp->replyref (r); }
      void reply (ptr< ::rtftp_get2_res_t> r) { check_reply (); _sbp->reply (r); }
      ptr<rtftp_get2_res_t> alloc_res ()  { return New refcounted<rtftp_get2_res_t> (); }
      template<class T> ptr<rtftp_get2_res_t>
      alloc_res (const T &t)  { return New refcounted<rtftp_get2_res_t> (t); }
      S *sbp () { return _sbp; }
      const S *sbp () const { return _sbp; }
      void reject (auth_stat s) { check_reply (); _sbp->reject (s); }
      void reject (accept_stat s) { check_reply (); _sbp->reject (s); }
      void reject () { check_reply (); _sbp->reject (); }

      typedef rtftp_get2_arg_t arg_ty;

      typedef rtftp_get2_res_t res_ty;

      template<class C, class E> void
      call_full(C c, const rtftp_get2_arg_t *arg, rtftp_get2_res_t *res, E cb)
      { c->call (RTFTP_GET2, arg, res, cb); }

      template<class C, class E>
      void call(C c, const rtftp_get2_arg_t* arg, rtftp_get2_res_t* res, E cb)
      { rtftp_get2(c, arg, res, cb); }

    private:
      void check_reply () { assert (!_replied); _replied = true; }
      bool _replied;
      S *_sbp;
    };

  };
};

#define RTFTP_TCP_PORT 5401
#define RTFTP_UDP_PORT 5402
#define MAX_PACKET_SIZE 0x8000000
/*
 *
 * MK note on RPC constant collection:
 *
 * The goal of this magic is to aggregate ALL of the RPC contants
 * in ALL of the .x files recursively included by your server
 * to be accessible at runtime to your server.  Thus, every
 * autogenerated .h protocol file will have one of these static
 * objects in it.  The static object itself doesn't do anything
 * other than call a constructor function, which in turn will
 * add this rpc_constant_collector_t hook (rtftp_prot_constant_collect)
 * to a global list of hooks (see rpc_add_cch_t in extensible_arpc.C)
 *
 */
extern void rtftp_prot_constant_collect (rpc_constant_collector_t *rcc);
static rpc_add_cch_t rtftp_prot_obj (rtftp_prot_constant_collect);

#endif /* !__RPCC_RTFTP_PROT_H_INCLUDED__ */
