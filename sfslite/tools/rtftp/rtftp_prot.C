// -*-c++-*-
/* This file was automatically generated by rpcc. */

#include "rtftp_prot.h"

#ifdef MAINTAINER

const strbuf &
rpc_print (const strbuf &sb, const rtftp_status_t &obj, int recdepth,
           const char *name, const char *prefix)
{
  const char *p;
  switch (obj) {
  case RTFTP_OK:
    p = "RTFTP_OK";
    break;
  case RTFTP_NOENT:
    p = "RTFTP_NOENT";
    break;
  case RTFTP_CORRUPT:
    p = "RTFTP_CORRUPT";
    break;
  case RTFTP_EOF:
    p = "RTFTP_EOF";
    break;
  case RTFTP_EEXISTS:
    p = "RTFTP_EEXISTS";
    break;
  case RTFTP_EFS:
    p = "RTFTP_EFS";
    break;
  case RTFTP_BEGIN:
    p = "RTFTP_BEGIN";
    break;
  case RTFTP_ERR:
    p = "RTFTP_ERR";
    break;
  case RTFTP_OUT_OF_SEQ:
    p = "RTFTP_OUT_OF_SEQ";
    break;
  case RTFTP_INCOMPLETE:
    p = "RTFTP_INCOMPLETE";
    break;
  default:
    p = NULL;
    break;
  }
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "rtftp_status_t " << name << " = ";
  };
  if (p)
    sb << p;
  else
    sb << int (obj);
  if (prefix)
    sb << ";\n";
  return sb;
};
void
print_rtftp_status_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                      const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const rtftp_status_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_rtftp_status_t (const rtftp_status_t *objp)
{
  rpc_print (warnx, *objp);
}

void
print_rtftp_hash_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                    const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const rtftp_hash_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_rtftp_hash_t (const rtftp_hash_t *objp)
{
  rpc_print (warnx, *objp);
}

void
print_rtftp_id_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                  const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const rtftp_id_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_rtftp_id_t (const rtftp_id_t *objp)
{
  rpc_print (warnx, *objp);
}

void
print_rtftp_data_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                    const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const rtftp_data_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_rtftp_data_t (const rtftp_data_t *objp)
{
  rpc_print (warnx, *objp);
}

void
print_rtftp_xfer_id_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                       const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const rtftp_xfer_id_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_rtftp_xfer_id_t (const rtftp_xfer_id_t *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const rtftp_file_t &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "rtftp_file_t " << name << " = ";
  };
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sb << "{\n";
  } else {
    sb << "{ ";
  }
  const char *sep = NULL;
  if (prefix) {
    sep = "";
  } else {
    sep = ", ";
  }
  rpc_print (sb, obj.magic, recdepth, "magic", npref.cstr());
  sb << sep;
  rpc_print (sb, obj.name, recdepth, "name", npref.cstr());
  sb << sep;
  rpc_print (sb, obj.hash, recdepth, "hash", npref.cstr());
  sb << sep;
  rpc_print (sb, obj.data, recdepth, "data", npref.cstr());
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_rtftp_file_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                    const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const rtftp_file_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_rtftp_file_t (const rtftp_file_t *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const rtftp_header_t &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "rtftp_header_t " << name << " = ";
  };
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sb << "{\n";
  } else {
    sb << "{ ";
  }
  const char *sep = NULL;
  if (prefix) {
    sep = "";
  } else {
    sep = ", ";
  }
  rpc_print (sb, obj.magic, recdepth, "magic", npref.cstr());
  sb << sep;
  rpc_print (sb, obj.name, recdepth, "name", npref.cstr());
  sb << sep;
  rpc_print (sb, obj.hash, recdepth, "hash", npref.cstr());
  sb << sep;
  rpc_print (sb, obj.size, recdepth, "size", npref.cstr());
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_rtftp_header_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                      const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const rtftp_header_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_rtftp_header_t (const rtftp_header_t *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const rtftp_xfer_header_t &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "rtftp_xfer_header_t " << name << " = ";
  };
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sb << "{\n";
  } else {
    sb << "{ ";
  }
  const char *sep = NULL;
  if (prefix) {
    sep = "";
  } else {
    sep = ", ";
  }
  rpc_print (sb, obj.xfer_id, recdepth, "xfer_id", npref.cstr());
  sb << sep;
  rpc_print (sb, obj.size, recdepth, "size", npref.cstr());
  sb << sep;
  rpc_print (sb, obj.hash, recdepth, "hash", npref.cstr());
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_rtftp_xfer_header_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                           const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const rtftp_xfer_header_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_rtftp_xfer_header_t (const rtftp_xfer_header_t *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const rtftp_chunkid_t &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "rtftp_chunkid_t " << name << " = ";
  };
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sb << "{\n";
  } else {
    sb << "{ ";
  }
  const char *sep = NULL;
  if (prefix) {
    sep = "";
  } else {
    sep = ", ";
  }
  rpc_print (sb, obj.xfer_id, recdepth, "xfer_id", npref.cstr());
  sb << sep;
  rpc_print (sb, obj.offset, recdepth, "offset", npref.cstr());
  sb << sep;
  rpc_print (sb, obj.size, recdepth, "size", npref.cstr());
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_rtftp_chunkid_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                       const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const rtftp_chunkid_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_rtftp_chunkid_t (const rtftp_chunkid_t *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const rtftp_chunk_t &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "rtftp_chunk_t " << name << " = ";
  };
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sb << "{\n";
  } else {
    sb << "{ ";
  }
  const char *sep = NULL;
  if (prefix) {
    sep = "";
  } else {
    sep = ", ";
  }
  rpc_print (sb, obj.id, recdepth, "id", npref.cstr());
  sb << sep;
  rpc_print (sb, obj.data, recdepth, "data", npref.cstr());
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_rtftp_chunk_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                     const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const rtftp_chunk_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_rtftp_chunk_t (const rtftp_chunk_t *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const rtftp_footer_t &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "rtftp_footer_t " << name << " = ";
  };
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sb << "{\n";
  } else {
    sb << "{ ";
  }
  const char *sep = NULL;
  if (prefix) {
    sep = "";
  } else {
    sep = ", ";
  }
  rpc_print (sb, obj.xfer_id, recdepth, "xfer_id", npref.cstr());
  sb << sep;
  rpc_print (sb, obj.size, recdepth, "size", npref.cstr());
  sb << sep;
  rpc_print (sb, obj.n_chunks, recdepth, "n_chunks", npref.cstr());
  sb << sep;
  rpc_print (sb, obj.hash, recdepth, "hash", npref.cstr());
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_rtftp_footer_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                      const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const rtftp_footer_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_rtftp_footer_t (const rtftp_footer_t *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const rtftp_get_res_t &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "rtftp_get_res_t " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.status, recdepth, "status", npref.cstr());
  switch (obj.status) {
  case RTFTP_OK:
    sb << sep;
    rpc_print (sb, *obj.file,  recdepth, "file", npref.cstr());
    break;
  default:
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_rtftp_get_res_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                       const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const rtftp_get_res_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_rtftp_get_res_t (const rtftp_get_res_t *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const rtftp_put2_res_t &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "rtftp_put2_res_t " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.status, recdepth, "status", npref.cstr());
  switch (obj.status) {
  case RTFTP_BEGIN:
    sb << sep;
    rpc_print (sb, *obj.xfer_id,  recdepth, "xfer_id", npref.cstr());
    break;
  default:
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_rtftp_put2_res_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                        const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const rtftp_put2_res_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_rtftp_put2_res_t (const rtftp_put2_res_t *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const rtftp_put2_arg_t &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "rtftp_put2_arg_t " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.status, recdepth, "status", npref.cstr());
  switch (obj.status) {
  case RTFTP_BEGIN:
    sb << sep;
    rpc_print (sb, *obj.name,  recdepth, "name", npref.cstr());
    break;
  case RTFTP_OK:
    sb << sep;
    rpc_print (sb, *obj.data,  recdepth, "data", npref.cstr());
    break;
  case RTFTP_EOF:
    sb << sep;
    rpc_print (sb, *obj.footer,  recdepth, "footer", npref.cstr());
    break;
  default:
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_rtftp_put2_arg_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                        const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const rtftp_put2_arg_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_rtftp_put2_arg_t (const rtftp_put2_arg_t *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const rtftp_get2_arg_t &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "rtftp_get2_arg_t " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.status, recdepth, "status", npref.cstr());
  switch (obj.status) {
  case RTFTP_BEGIN:
    sb << sep;
    rpc_print (sb, *obj.name,  recdepth, "name", npref.cstr());
    break;
  case RTFTP_OK:
    sb << sep;
    rpc_print (sb, *obj.chunk,  recdepth, "chunk", npref.cstr());
    break;
  case RTFTP_EOF:
    sb << sep;
    rpc_print (sb, *obj.id,  recdepth, "id", npref.cstr());
    break;
  default:
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_rtftp_get2_arg_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                        const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const rtftp_get2_arg_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_rtftp_get2_arg_t (const rtftp_get2_arg_t *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const rtftp_get2_res_t &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "rtftp_get2_res_t " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.status, recdepth, "status", npref.cstr());
  switch (obj.status) {
  case RTFTP_BEGIN:
    sb << sep;
    rpc_print (sb, *obj.header,  recdepth, "header", npref.cstr());
    break;
  case RTFTP_OK:
    sb << sep;
    rpc_print (sb, *obj.chunk,  recdepth, "chunk", npref.cstr());
    break;
  default:
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_rtftp_get2_res_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                        const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const rtftp_get2_res_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_rtftp_get2_res_t (const rtftp_get2_res_t *objp)
{
  rpc_print (warnx, *objp);
}

#endif /* MAINTAINER*/
void *
rtftp_status_t_alloc ()
{
  return New rtftp_status_t;
}
bool_t
xdr_rtftp_status_t (XDR *xdrs, void *objp)
{
  bool_t ret = false;
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    {
      ptr<v_XDR_t> v = xdr_virtualize (xdrs);
      if (v) {
        ret = rpc_traverse (v, *static_cast<rtftp_status_t *> (objp));
      } else {
        ret = rpc_traverse (xdrs, *static_cast<rtftp_status_t *> (objp));
      }
    }
    break;
  case XDR_FREE:
    rpc_destruct (static_cast<rtftp_status_t *> (objp));
    ret = true;
    break;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
    break;
  }
  return ret;
}

void *
rtftp_hash_t_alloc ()
{
  return New rtftp_hash_t;
}
bool_t
xdr_rtftp_hash_t (XDR *xdrs, void *objp)
{
  bool_t ret = false;
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    {
      ptr<v_XDR_t> v = xdr_virtualize (xdrs);
      if (v) {
        ret = rpc_traverse (v, *static_cast<rtftp_hash_t *> (objp));
      } else {
        ret = rpc_traverse (xdrs, *static_cast<rtftp_hash_t *> (objp));
      }
    }
    break;
  case XDR_FREE:
    rpc_destruct (static_cast<rtftp_hash_t *> (objp));
    ret = true;
    break;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
    break;
  }
  return ret;
}

void *
rtftp_id_t_alloc ()
{
  return New rtftp_id_t;
}
bool_t
xdr_rtftp_id_t (XDR *xdrs, void *objp)
{
  bool_t ret = false;
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    {
      ptr<v_XDR_t> v = xdr_virtualize (xdrs);
      if (v) {
        ret = rpc_traverse (v, *static_cast<rtftp_id_t *> (objp));
      } else {
        ret = rpc_traverse (xdrs, *static_cast<rtftp_id_t *> (objp));
      }
    }
    break;
  case XDR_FREE:
    rpc_destruct (static_cast<rtftp_id_t *> (objp));
    ret = true;
    break;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
    break;
  }
  return ret;
}

void *
rtftp_data_t_alloc ()
{
  return New rtftp_data_t;
}
bool_t
xdr_rtftp_data_t (XDR *xdrs, void *objp)
{
  bool_t ret = false;
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    {
      ptr<v_XDR_t> v = xdr_virtualize (xdrs);
      if (v) {
        ret = rpc_traverse (v, *static_cast<rtftp_data_t *> (objp));
      } else {
        ret = rpc_traverse (xdrs, *static_cast<rtftp_data_t *> (objp));
      }
    }
    break;
  case XDR_FREE:
    rpc_destruct (static_cast<rtftp_data_t *> (objp));
    ret = true;
    break;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
    break;
  }
  return ret;
}

void *
rtftp_xfer_id_t_alloc ()
{
  return New rtftp_xfer_id_t;
}
bool_t
xdr_rtftp_xfer_id_t (XDR *xdrs, void *objp)
{
  bool_t ret = false;
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    {
      ptr<v_XDR_t> v = xdr_virtualize (xdrs);
      if (v) {
        ret = rpc_traverse (v, *static_cast<rtftp_xfer_id_t *> (objp));
      } else {
        ret = rpc_traverse (xdrs, *static_cast<rtftp_xfer_id_t *> (objp));
      }
    }
    break;
  case XDR_FREE:
    rpc_destruct (static_cast<rtftp_xfer_id_t *> (objp));
    ret = true;
    break;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
    break;
  }
  return ret;
}

void *
rtftp_file_t_alloc ()
{
  return New rtftp_file_t;
}
bool_t
xdr_rtftp_file_t (XDR *xdrs, void *objp)
{
  bool_t ret = false;
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    {
      ptr<v_XDR_t> v = xdr_virtualize (xdrs);
      if (v) {
        ret = rpc_traverse (v, *static_cast<rtftp_file_t *> (objp));
      } else {
        ret = rpc_traverse (xdrs, *static_cast<rtftp_file_t *> (objp));
      }
    }
    break;
  case XDR_FREE:
    rpc_destruct (static_cast<rtftp_file_t *> (objp));
    ret = true;
    break;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
    break;
  }
  return ret;
}

void *
rtftp_header_t_alloc ()
{
  return New rtftp_header_t;
}
bool_t
xdr_rtftp_header_t (XDR *xdrs, void *objp)
{
  bool_t ret = false;
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    {
      ptr<v_XDR_t> v = xdr_virtualize (xdrs);
      if (v) {
        ret = rpc_traverse (v, *static_cast<rtftp_header_t *> (objp));
      } else {
        ret = rpc_traverse (xdrs, *static_cast<rtftp_header_t *> (objp));
      }
    }
    break;
  case XDR_FREE:
    rpc_destruct (static_cast<rtftp_header_t *> (objp));
    ret = true;
    break;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
    break;
  }
  return ret;
}

void *
rtftp_xfer_header_t_alloc ()
{
  return New rtftp_xfer_header_t;
}
bool_t
xdr_rtftp_xfer_header_t (XDR *xdrs, void *objp)
{
  bool_t ret = false;
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    {
      ptr<v_XDR_t> v = xdr_virtualize (xdrs);
      if (v) {
        ret = rpc_traverse (v, *static_cast<rtftp_xfer_header_t *> (objp));
      } else {
        ret = rpc_traverse (xdrs, *static_cast<rtftp_xfer_header_t *> (objp));
      }
    }
    break;
  case XDR_FREE:
    rpc_destruct (static_cast<rtftp_xfer_header_t *> (objp));
    ret = true;
    break;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
    break;
  }
  return ret;
}

void *
rtftp_chunkid_t_alloc ()
{
  return New rtftp_chunkid_t;
}
bool_t
xdr_rtftp_chunkid_t (XDR *xdrs, void *objp)
{
  bool_t ret = false;
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    {
      ptr<v_XDR_t> v = xdr_virtualize (xdrs);
      if (v) {
        ret = rpc_traverse (v, *static_cast<rtftp_chunkid_t *> (objp));
      } else {
        ret = rpc_traverse (xdrs, *static_cast<rtftp_chunkid_t *> (objp));
      }
    }
    break;
  case XDR_FREE:
    rpc_destruct (static_cast<rtftp_chunkid_t *> (objp));
    ret = true;
    break;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
    break;
  }
  return ret;
}

void *
rtftp_chunk_t_alloc ()
{
  return New rtftp_chunk_t;
}
bool_t
xdr_rtftp_chunk_t (XDR *xdrs, void *objp)
{
  bool_t ret = false;
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    {
      ptr<v_XDR_t> v = xdr_virtualize (xdrs);
      if (v) {
        ret = rpc_traverse (v, *static_cast<rtftp_chunk_t *> (objp));
      } else {
        ret = rpc_traverse (xdrs, *static_cast<rtftp_chunk_t *> (objp));
      }
    }
    break;
  case XDR_FREE:
    rpc_destruct (static_cast<rtftp_chunk_t *> (objp));
    ret = true;
    break;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
    break;
  }
  return ret;
}

void *
rtftp_footer_t_alloc ()
{
  return New rtftp_footer_t;
}
bool_t
xdr_rtftp_footer_t (XDR *xdrs, void *objp)
{
  bool_t ret = false;
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    {
      ptr<v_XDR_t> v = xdr_virtualize (xdrs);
      if (v) {
        ret = rpc_traverse (v, *static_cast<rtftp_footer_t *> (objp));
      } else {
        ret = rpc_traverse (xdrs, *static_cast<rtftp_footer_t *> (objp));
      }
    }
    break;
  case XDR_FREE:
    rpc_destruct (static_cast<rtftp_footer_t *> (objp));
    ret = true;
    break;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
    break;
  }
  return ret;
}

void *
rtftp_get_res_t_alloc ()
{
  return New rtftp_get_res_t;
}
bool_t
xdr_rtftp_get_res_t (XDR *xdrs, void *objp)
{
  bool_t ret = false;
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    {
      ptr<v_XDR_t> v = xdr_virtualize (xdrs);
      if (v) {
        ret = rpc_traverse (v, *static_cast<rtftp_get_res_t *> (objp));
      } else {
        ret = rpc_traverse (xdrs, *static_cast<rtftp_get_res_t *> (objp));
      }
    }
    break;
  case XDR_FREE:
    rpc_destruct (static_cast<rtftp_get_res_t *> (objp));
    ret = true;
    break;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
    break;
  }
  return ret;
}

void *
rtftp_put2_res_t_alloc ()
{
  return New rtftp_put2_res_t;
}
bool_t
xdr_rtftp_put2_res_t (XDR *xdrs, void *objp)
{
  bool_t ret = false;
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    {
      ptr<v_XDR_t> v = xdr_virtualize (xdrs);
      if (v) {
        ret = rpc_traverse (v, *static_cast<rtftp_put2_res_t *> (objp));
      } else {
        ret = rpc_traverse (xdrs, *static_cast<rtftp_put2_res_t *> (objp));
      }
    }
    break;
  case XDR_FREE:
    rpc_destruct (static_cast<rtftp_put2_res_t *> (objp));
    ret = true;
    break;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
    break;
  }
  return ret;
}

void *
rtftp_put2_arg_t_alloc ()
{
  return New rtftp_put2_arg_t;
}
bool_t
xdr_rtftp_put2_arg_t (XDR *xdrs, void *objp)
{
  bool_t ret = false;
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    {
      ptr<v_XDR_t> v = xdr_virtualize (xdrs);
      if (v) {
        ret = rpc_traverse (v, *static_cast<rtftp_put2_arg_t *> (objp));
      } else {
        ret = rpc_traverse (xdrs, *static_cast<rtftp_put2_arg_t *> (objp));
      }
    }
    break;
  case XDR_FREE:
    rpc_destruct (static_cast<rtftp_put2_arg_t *> (objp));
    ret = true;
    break;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
    break;
  }
  return ret;
}

void *
rtftp_get2_arg_t_alloc ()
{
  return New rtftp_get2_arg_t;
}
bool_t
xdr_rtftp_get2_arg_t (XDR *xdrs, void *objp)
{
  bool_t ret = false;
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    {
      ptr<v_XDR_t> v = xdr_virtualize (xdrs);
      if (v) {
        ret = rpc_traverse (v, *static_cast<rtftp_get2_arg_t *> (objp));
      } else {
        ret = rpc_traverse (xdrs, *static_cast<rtftp_get2_arg_t *> (objp));
      }
    }
    break;
  case XDR_FREE:
    rpc_destruct (static_cast<rtftp_get2_arg_t *> (objp));
    ret = true;
    break;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
    break;
  }
  return ret;
}

void *
rtftp_get2_res_t_alloc ()
{
  return New rtftp_get2_res_t;
}
bool_t
xdr_rtftp_get2_res_t (XDR *xdrs, void *objp)
{
  bool_t ret = false;
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    {
      ptr<v_XDR_t> v = xdr_virtualize (xdrs);
      if (v) {
        ret = rpc_traverse (v, *static_cast<rtftp_get2_res_t *> (objp));
      } else {
        ret = rpc_traverse (xdrs, *static_cast<rtftp_get2_res_t *> (objp));
      }
    }
    break;
  case XDR_FREE:
    rpc_destruct (static_cast<rtftp_get2_res_t *> (objp));
    ret = true;
    break;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
    break;
  }
  return ret;
}

static const rpcgen_table rtftp_program_1_tbl[] = {
  RTFTP_PROGRAM_1_APPLY (XDRTBL_DECL)
};
const rpc_program rtftp_program_1 = {
  RTFTP_PROGRAM, RTFTP_VERS, rtftp_program_1_tbl,
  sizeof (rtftp_program_1_tbl) / sizeof (rtftp_program_1_tbl[0]),
  "rtftp_program_1"
};

void
rtftp_prot_constant_collect (rpc_constant_collector_t *rcc)
{
  rcc->collect ("RTFTP_OK", RTFTP_OK, RPC_CONSTANT_ENUM);
  rcc->collect ("RTFTP_NOENT", RTFTP_NOENT, RPC_CONSTANT_ENUM);
  rcc->collect ("RTFTP_CORRUPT", RTFTP_CORRUPT, RPC_CONSTANT_ENUM);
  rcc->collect ("RTFTP_EOF", RTFTP_EOF, RPC_CONSTANT_ENUM);
  rcc->collect ("RTFTP_EEXISTS", RTFTP_EEXISTS, RPC_CONSTANT_ENUM);
  rcc->collect ("RTFTP_EFS", RTFTP_EFS, RPC_CONSTANT_ENUM);
  rcc->collect ("RTFTP_BEGIN", RTFTP_BEGIN, RPC_CONSTANT_ENUM);
  rcc->collect ("RTFTP_ERR", RTFTP_ERR, RPC_CONSTANT_ENUM);
  rcc->collect ("RTFTP_OUT_OF_SEQ", RTFTP_OUT_OF_SEQ, RPC_CONSTANT_ENUM);
  rcc->collect ("RTFTP_INCOMPLETE", RTFTP_INCOMPLETE, RPC_CONSTANT_ENUM);
  rcc->collect ("RTFTP_HASHSZ", RTFTP_HASHSZ, RPC_CONSTANT_POUND_DEF);
  rcc->collect ("CHUNKSZ", CHUNKSZ, RPC_CONSTANT_POUND_DEF);
  rcc->collect ("MAGIC", MAGIC, RPC_CONSTANT_POUND_DEF);
  rcc->collect ("RTFTP_PROGRAM", RTFTP_PROGRAM, RPC_CONSTANT_PROG);
  rcc->collect ("RTFTP_VERS", RTFTP_VERS, RPC_CONSTANT_VERS);
  rcc->collect ("RTFTP_NULL", RTFTP_NULL, RPC_CONSTANT_PROC);
  rcc->collect ("RTFTP_CHECK", RTFTP_CHECK, RPC_CONSTANT_PROC);
  rcc->collect ("RTFTP_PUT", RTFTP_PUT, RPC_CONSTANT_PROC);
  rcc->collect ("RTFTP_GET", RTFTP_GET, RPC_CONSTANT_PROC);
  rcc->collect ("RTFTP_PUT2", RTFTP_PUT2, RPC_CONSTANT_PROC);
  rcc->collect ("RTFTP_GET2", RTFTP_GET2, RPC_CONSTANT_PROC);
  rcc->collect ("RTFTP_TCP_PORT", RTFTP_TCP_PORT, RPC_CONSTANT_POUND_DEF);
  rcc->collect ("RTFTP_UDP_PORT", RTFTP_UDP_PORT, RPC_CONSTANT_POUND_DEF);
  rcc->collect ("MAX_PACKET_SIZE", MAX_PACKET_SIZE, RPC_CONSTANT_POUND_DEF);
  rcc->collect ("rtftp_status_t", xdr_procpair_t (rtftp_status_t_alloc, xdr_rtftp_status_t));
  rcc->collect ("rtftp_hash_t", xdr_procpair_t (rtftp_hash_t_alloc, xdr_rtftp_hash_t));
  rcc->collect ("rtftp_id_t", xdr_procpair_t (rtftp_id_t_alloc, xdr_rtftp_id_t));
  rcc->collect ("rtftp_data_t", xdr_procpair_t (rtftp_data_t_alloc, xdr_rtftp_data_t));
  rcc->collect ("rtftp_xfer_id_t", xdr_procpair_t (rtftp_xfer_id_t_alloc, xdr_rtftp_xfer_id_t));
  rcc->collect ("rtftp_file_t", xdr_procpair_t (rtftp_file_t_alloc, xdr_rtftp_file_t));
  rcc->collect ("rtftp_header_t", xdr_procpair_t (rtftp_header_t_alloc, xdr_rtftp_header_t));
  rcc->collect ("rtftp_xfer_header_t", xdr_procpair_t (rtftp_xfer_header_t_alloc, xdr_rtftp_xfer_header_t));
  rcc->collect ("rtftp_chunkid_t", xdr_procpair_t (rtftp_chunkid_t_alloc, xdr_rtftp_chunkid_t));
  rcc->collect ("rtftp_chunk_t", xdr_procpair_t (rtftp_chunk_t_alloc, xdr_rtftp_chunk_t));
  rcc->collect ("rtftp_footer_t", xdr_procpair_t (rtftp_footer_t_alloc, xdr_rtftp_footer_t));
  rcc->collect ("rtftp_get_res_t", xdr_procpair_t (rtftp_get_res_t_alloc, xdr_rtftp_get_res_t));
  rcc->collect ("rtftp_put2_res_t", xdr_procpair_t (rtftp_put2_res_t_alloc, xdr_rtftp_put2_res_t));
  rcc->collect ("rtftp_put2_arg_t", xdr_procpair_t (rtftp_put2_arg_t_alloc, xdr_rtftp_put2_arg_t));
  rcc->collect ("rtftp_get2_arg_t", xdr_procpair_t (rtftp_get2_arg_t_alloc, xdr_rtftp_get2_arg_t));
  rcc->collect ("rtftp_get2_res_t", xdr_procpair_t (rtftp_get2_res_t_alloc, xdr_rtftp_get2_res_t));
}


