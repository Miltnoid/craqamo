\section{Related Work}

\subsection{Chain Replication (CR)}
The chain replication storage system is a distributed object storage system which is capable of providing strongly consistent operations. In chain replication, data-centers (or nodes) are linked in a chain in which only neighboring communication is allowed in normal cases. The chain replication storage system supports two operations {\it read} and {\it write}. All read operations are handled by the tail and all write operations are handled by the head. During writing, the new data needs to be propagated from the head to the tail until the updated object is marked as committed. When a read request occurs, the tail node simply returns the newest committed object. While the working mechanism of chain replication is simple, it is obvious that the latency of both read and write operations can be very high, especially when the nodes are placed geographically distant to each other. For example, if the tail node is placed in the US, users from other countries still need to request data from the tail and the latency is expected to be high. The situation gets even worse for write operations because the new data needs to be propagated all the way from the head to the tail and it also results in high latency.

\subsection{CRAQ}
CRAQ is a variant of the chain replication storage system and it targets at improving the throughput of strongly consistent read operations by allowing users to access data from any node in the chain. The idea is to let each node keep several versions of data, and to use a flag indicating whether the version is {\it dirty} or {\it clean}. In terms of keeping track of the version, CRAQ simply uses a monotonically-increasing integer as the version number of the object. {\it Clean} flag means that the version is committed and it is safe to directly return it to the requester. {\it Dirty} flag means that the newly written data is still being propagated in the chain or the commitment message is still being propagated back from the tail. Then the current node needs to ask the tail for the latest committed version number and returns the data associated with that version number. This modification greatly improves the read throughput of CR as in most cases, the newest version of object is ready to be returned. CRAQ also naturally supports eventually consistent read operations because each node keeps multiple versions of objects and eventual consistency read can be easily achieved by directly returning the latest version. However, CRAQ only supports strongly consistent write operations, so the write throughput still remains a bottleneck for CRAQ.

\subsection{Dynamo}
Dynamo is a high available key-value storage system deployed by Amazon. The main observation through Amazon's own services is that sometimes availability is highly preferred so that it is possible to sacrifice strong consistency for high availability. In order to further increase write throughput, conflict resolution is executed during read instead of write so that write operations look instant to the clients, giving an "always-on" experience. Unlike chain replication, Dynamo uses consistent hashing to partition the data, and each node takes care of a number of keys as well as a number of the nodes before it depending on the number of replicas desired. One major advantage of Dynamo is allowing users to tune a few parameters including the number of replicas, the number of read confirmations and the number of write confirmations so that the trade-offs are always in control. For example, increasing the number of write confirmations, although increases consistency, increases the latency at the same time. In CRAQamo, we adopt the parameter tuning idea in Dynamo to control the consistency. 

\subsection{Eiger}
Eiger is a geo-replicated storage system which provides low latency, causal consistency, read-only and write-only transactions. All client requests can be satisfied in the local data center. Eiger supports useful data model abstractions such as column-families and counter columns which provides rich structure allowing programmers to represent and query data efficiently. Eiger provides causal consistency and allows clients to access data with non-blocking read-only and write-only transactions. The problem of Eiger is that all the objects applies a single consistency model. In practice, some objects require strong consistency while others do not. CRAQamo solves this problem by combing hybridizing both strongly consistent operations and eventually consistent operations. 

\label{sec:related}

