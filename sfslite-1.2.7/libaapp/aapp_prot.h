// -*-c++-*-
/* This file was automatically generated by rpcc. */

#ifndef __RPCC_AAPP_PROT_H_INCLUDED__
#define __RPCC_AAPP_PROT_H_INCLUDED__ 1

#include "xdrmisc.h"

enum ip_vers_t {
  IP_V4 = 4,
};
void *ip_vers_t_alloc ();
bool_t xdr_ip_vers_t (XDR *, void *);
RPC_ENUM_DECL (ip_vers_t)
TYPE2STRUCT( , ip_vers_t);

template<class T> inline bool
rpc_traverse (T &t, ip_vers_t &obj)
{
  u_int32_t val = obj;
  if (!rpc_traverse (t, val))
    return false;
  obj = ip_vers_t (val);
  return true;
}


struct x_ip_addr_t {
  const ip_vers_t vers;
  union {
    union_entry_base _base;
    union_entry<u_int32_t> v4;
  };

#define rpcunion_tag_x_ip_addr_t vers
#define rpcunion_switch_x_ip_addr_t(swarg, action, voidaction, defaction) \
  switch (swarg) { \
  case IP_V4: \
    action (u_int32_t, v4); \
    break; \
  default: \
    voidaction; \
    break; \
  }

  x_ip_addr_t (ip_vers_t _tag = (ip_vers_t) 0) : vers (_tag)
    { _base.init (); set_vers (_tag); }
  x_ip_addr_t (const x_ip_addr_t &_s)
    : vers (_s.vers)
    { _base.init (_s._base); }
  ~x_ip_addr_t () { _base.destroy (); }
  x_ip_addr_t &operator= (const x_ip_addr_t &_s) {
    const_cast<ip_vers_t &> (vers) = _s.vers;
    _base.assign (_s._base);
    return *this;
  }

  void set_vers (ip_vers_t _tag) {
    const_cast<ip_vers_t &> (vers) = _tag;
    rpcunion_switch_x_ip_addr_t
      (_tag, RPCUNION_SET, _base.destroy (), _base.destroy ());
  }
};

template<class T> bool
rpc_traverse (T &t, x_ip_addr_t &obj)
{
  ip_vers_t tag = obj.vers;
  if (!rpc_traverse (t, tag))
    return false;
  if (tag != obj.vers)
    obj.set_vers (tag);

  rpcunion_switch_x_ip_addr_t
    (obj.vers, RPCUNION_TRAVERSE, return true, return false);
  /* gcc 4.0.3 makes buggy warnings without the following line */
  return false;
}
inline bool
rpc_traverse (const stompcast_t &s, x_ip_addr_t &obj)
{
  rpcunion_switch_x_ip_addr_t
    (obj.vers, RPCUNION_REC_STOMPCAST,
     obj._base.destroy (); return true, obj._base.destroy (); return true;);
  /* gcc 4.0.3 makes buggy warnings without the following line */
  return false;
}
void *x_ip_addr_t_alloc ();
bool_t xdr_x_ip_addr_t (XDR *, void *);
RPC_UNION_DECL (x_ip_addr_t)



struct x_host_addr_t {
  x_ip_addr_t ip_addr;
  u_int32_t port;
};
void *x_host_addr_t_alloc ();
bool_t xdr_x_host_addr_t (XDR *, void *);
RPC_STRUCT_DECL (x_host_addr_t)

template<class T> bool
rpc_traverse (T &t, x_host_addr_t &obj)
{
  return rpc_traverse (t, obj.ip_addr)
    && rpc_traverse (t, obj.port);
}



struct aapp_newcon_t {
  x_host_addr_t addr;
};
void *aapp_newcon_t_alloc ();
bool_t xdr_aapp_newcon_t (XDR *, void *);
RPC_STRUCT_DECL (aapp_newcon_t)

template<class T> inline bool
rpc_traverse (T &t, aapp_newcon_t &obj)
{
  return rpc_traverse (t, obj.addr);
}


enum aapp_status_t {
  AAPP_OK = 0,
  AAPP_BAD_FD = 1,
  AAPP_ERR = 2,
};
void *aapp_status_t_alloc ();
bool_t xdr_aapp_status_t (XDR *, void *);
RPC_ENUM_DECL (aapp_status_t)
TYPE2STRUCT( , aapp_status_t);

template<class T> inline bool
rpc_traverse (T &t, aapp_status_t &obj)
{
  u_int32_t val = obj;
  if (!rpc_traverse (t, val))
    return false;
  obj = aapp_status_t (val);
  return true;
}

#ifndef AAPP_SERVER_PROG
#define AAPP_SERVER_PROG 5402
#endif /* !AAPP_SERVER_PROG */
extern const rpc_program aapp_server_prog_1;
enum { APP_SERVER_VERS = 1 };
enum {
  AAPP_SERVER_NULL = 0,
  AAPP_SERVER_NEWCON = 1,
};
#define AAPP_SERVER_PROG_1_APPLY_NOVOID(macro, void) \
  macro (AAPP_SERVER_NULL, void, void) \
  macro (AAPP_SERVER_NEWCON, aapp_newcon_t, aapp_status_t)
#define AAPP_SERVER_PROG_1_APPLY(macro) \
  AAPP_SERVER_PROG_1_APPLY_NOVOID(macro, void)

namespace RPC {
  namespace aapp_server_prog_1 {

    // AAPP_SERVER_NULL -----------------------------------------

    template<class C, class E> void
    aapp_server_null(C c, E cb)
    { c->call (AAPP_SERVER_NULL, NULL, NULL, cb); }

    template<class E> void
    w_aapp_server_null(typename callback<void,rpc_bundle_t,E>::ref c, E cb)
    { (*c) ( rpc_bundle_t (AAPP_SERVER_NULL, NULL, NULL), cb); }

    template<class R, class E> R
    w_aapp_server_null(typename callback<R,rpc_bundle_t,E>::ref c, E cb)
    { return (*c) ( rpc_bundle_t (AAPP_SERVER_NULL, NULL, NULL), cb); }

    template<class S>
    class aapp_server_null_srv_t {
    public:
      aapp_server_null_srv_t(S *s) : _replied (false), _sbp (s) {}
      void reply () { check_reply (); _sbp->reply (NULL); }
      S *sbp () { return _sbp; }
      const S *sbp () const { return _sbp; }
      void reject (auth_stat s) { check_reply (); _sbp->reject (s); }
      void reject (accept_stat s) { check_reply (); _sbp->reject (s); }
      void reject () { check_reply (); _sbp->reject (); }

    private:
      void check_reply () { assert (!_replied); _replied = true; }
      bool _replied;
      S *_sbp;
    };


    // AAPP_SERVER_NEWCON -----------------------------------------

    template<class C, class E> void
    aapp_server_newcon(C c, const aapp_newcon_t *arg, aapp_status_t *res, E cb)
    { c->call (AAPP_SERVER_NEWCON, arg, res, cb); }

    template<class C, class E> void
    aapp_server_newcon(C c, const aapp_newcon_t &arg, aapp_status_t *res, E cb)
    { c->call (AAPP_SERVER_NEWCON, &arg, res, cb); }

    template<class E> void
    w_aapp_server_newcon(typename callback<void,rpc_bundle_t,E>::ref c, const aapp_newcon_t *arg, aapp_status_t *res, E cb)
    { (*c) ( rpc_bundle_t (AAPP_SERVER_NEWCON, arg, res), cb); }

    template<class E> void
    w_aapp_server_newcon(typename callback<void,rpc_bundle_t,E>::ref c, const aapp_newcon_t &arg, aapp_status_t *res, E cb)
    { (*c) ( rpc_bundle_t (AAPP_SERVER_NEWCON, &arg, res), cb); }

    template<class R, class E> R
    w_aapp_server_newcon(typename callback<R,rpc_bundle_t,E>::ref c, const aapp_newcon_t *arg, aapp_status_t *res, E cb)
    { return (*c) ( rpc_bundle_t (AAPP_SERVER_NEWCON, arg, res), cb); }

    template<class R, class E> R
    w_aapp_server_newcon(typename callback<R,rpc_bundle_t,E>::ref c, const aapp_newcon_t &arg, aapp_status_t *res, E cb)
    { return (*c) ( rpc_bundle_t (AAPP_SERVER_NEWCON, &arg, res), cb); }

    template<class S>
    class aapp_server_newcon_srv_t {
    public:
      aapp_server_newcon_srv_t(S *s) : _replied (false), _sbp (s) {}
      const ::aapp_newcon_t* getarg() const {  return static_cast<aapp_newcon_t*> (_sbp->getvoidarg ()); }
      ::aapp_newcon_t* getarg() {  return static_cast<aapp_newcon_t*> (_sbp->getvoidarg ()); }
      void reply (const ::aapp_status_t *r) { check_reply (); _sbp->reply (r); }
      void reply (const ::aapp_status_t &r) { check_reply (); _sbp->replyref (r); }
      void reply (ptr< ::aapp_status_t> r) { check_reply (); _sbp->reply (r); }
      ptr<aapp_status_t> alloc_res ()  { return New refcounted<aapp_status_t> (); }
      template<class T> ptr<aapp_status_t>
      alloc_res (const T &t)  { return New refcounted<aapp_status_t> (t); }
      S *sbp () { return _sbp; }
      const S *sbp () const { return _sbp; }
      void reject (auth_stat s) { check_reply (); _sbp->reject (s); }
      void reject (accept_stat s) { check_reply (); _sbp->reject (s); }
      void reject () { check_reply (); _sbp->reject (); }

    private:
      void check_reply () { assert (!_replied); _replied = true; }
      bool _replied;
      S *_sbp;
    };

  };
};
#endif /* !__RPCC_AAPP_PROT_H_INCLUDED__ */
