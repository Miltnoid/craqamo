// -*-c++-*-
/* This file was automatically generated by rpcc. */

#include "aapp_prot.h"

#ifdef MAINTAINER

const strbuf &
rpc_print (const strbuf &sb, const ip_vers_t &obj, int recdepth,
           const char *name, const char *prefix)
{
  const char *p;
  switch (obj) {
  case IP_V4:
    p = "IP_V4";
    break;
  default:
    p = NULL;
    break;
  }
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "ip_vers_t " << name << " = ";
  };
  if (p)
    sb << p;
  else
    sb << int (obj);
  if (prefix)
    sb << ";\n";
  return sb;
};
void
print_ip_vers_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                 const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const ip_vers_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_ip_vers_t (const ip_vers_t *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const x_ip_addr_t &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "x_ip_addr_t " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.vers, recdepth, "vers", npref);
  switch (obj.vers) {
  case IP_V4:
    sb << sep;
    rpc_print (sb, *obj.v4,  recdepth, "v4", npref);
    break;
  default:
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_x_ip_addr_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                   const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const x_ip_addr_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_x_ip_addr_t (const x_ip_addr_t *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const x_host_addr_t &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "x_host_addr_t " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.ip_addr, recdepth, "ip_addr", npref);
  sb << sep;
  rpc_print (sb, obj.port, recdepth, "port", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_x_host_addr_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                     const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const x_host_addr_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_x_host_addr_t (const x_host_addr_t *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const aapp_newcon_t &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "aapp_newcon_t " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.addr, recdepth, "addr", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_aapp_newcon_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                     const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const aapp_newcon_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_aapp_newcon_t (const aapp_newcon_t *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const aapp_status_t &obj, int recdepth,
           const char *name, const char *prefix)
{
  const char *p;
  switch (obj) {
  case AAPP_OK:
    p = "AAPP_OK";
    break;
  case AAPP_BAD_FD:
    p = "AAPP_BAD_FD";
    break;
  case AAPP_ERR:
    p = "AAPP_ERR";
    break;
  default:
    p = NULL;
    break;
  }
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "aapp_status_t " << name << " = ";
  };
  if (p)
    sb << p;
  else
    sb << int (obj);
  if (prefix)
    sb << ";\n";
  return sb;
};
void
print_aapp_status_t (const void *_objp, const strbuf *_sbp, int _recdepth,
                     const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const aapp_status_t *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_aapp_status_t (const aapp_status_t *objp)
{
  rpc_print (warnx, *objp);
}

#endif /* MAINTAINER*/
void *
ip_vers_t_alloc ()
{
  return New ip_vers_t;
}
bool_t
xdr_ip_vers_t (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<ip_vers_t *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<ip_vers_t *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
x_ip_addr_t_alloc ()
{
  return New x_ip_addr_t;
}
bool_t
xdr_x_ip_addr_t (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<x_ip_addr_t *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<x_ip_addr_t *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
x_host_addr_t_alloc ()
{
  return New x_host_addr_t;
}
bool_t
xdr_x_host_addr_t (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<x_host_addr_t *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<x_host_addr_t *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
aapp_newcon_t_alloc ()
{
  return New aapp_newcon_t;
}
bool_t
xdr_aapp_newcon_t (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<aapp_newcon_t *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<aapp_newcon_t *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
aapp_status_t_alloc ()
{
  return New aapp_status_t;
}
bool_t
xdr_aapp_status_t (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<aapp_status_t *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<aapp_status_t *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

static const rpcgen_table aapp_server_prog_1_tbl[] = {
  AAPP_SERVER_PROG_1_APPLY (XDRTBL_DECL)
};
const rpc_program aapp_server_prog_1 = {
  AAPP_SERVER_PROG, APP_SERVER_VERS, aapp_server_prog_1_tbl,
  sizeof (aapp_server_prog_1_tbl) / sizeof (aapp_server_prog_1_tbl[0]),
  "aapp_server_prog_1"
};


