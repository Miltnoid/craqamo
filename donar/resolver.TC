
# 1 "resolver.T"
#include <cstdio>
#include <cstdlib>
#include <cerrno>
#include <cstring>
#include <sstream>
#include <iostream>
#include <fstream>
#include <unistd.h>
#include <sys/types.h> 
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include "tame.h"
#include "tame_io.h"
#include "async.h"
#include "resolver.h"
#include "arpc.h"
#include "donar_rpc.h"
#include "tame_rpcserver.h"
#include "mysql_connection.h"
#include "client/craq_interface.h"
#include "cppconn/driver.h"
#include "cppconn/connection.h"
#include "cppconn/statement.h"
#include "cppconn/prepared_statement.h"
#include "cppconn/resultset.h"
#include "cppconn/metadata.h"
#include "cppconn/resultset_metadata.h"
#include "cppconn/exception.h"
#include "cppconn/warning.h"
#include "mosek.h"
#include <tr1/unordered_map>
#include <tr1/unordered_set>

str sock_path;
str mosek_file;
str mysql_user;
str mysql_pass;
str mysql_host;
str zoo_list;
ofstream logfile;
bool debug;

#define LOG_EXPIRY_MINUTES 15
#define LOG_CLEAN_INTERVAL_MINS 15
#define MAX_A_RECORDS 1

using namespace std;
using namespace sql;

const unsigned int MAX_BUFF = 1000;
Connection* quova_conn;
Connection* donar_conn;
craq_interface craq;
unsigned int my_ip_addr;
unsigned int update_interval;
unsigned int max_cache_period;

string last; // PDNS hack

// Store subdomains in a hash-set for quick lookup
tr1::unordered_set<SubdomainInfo, SubdomainHash, SubdomainEqual> 
  subdomain_cache;
tr1::unordered_set<SubdomainInfo, SubdomainHash, SubdomainEqual>::iterator
  subdomain_cache_it;

// Cache of IP location lookups so we don't hit quova as often
tr1::unordered_map<unsigned long, ClientRegion> location_cache;
tr1::unordered_map<unsigned long, ClientRegion>:: iterator location_cache_it;

ClientRegion::ClientRegion(int lat, int lon) {
  this->lat = lat;
  this->lon = lon;
}

ClientRegion::ClientRegion() {
}

ostream& operator<<(ostream& s, ClientRegion &cr) {
  s << "Client Region: (" << cr.lat << ", " << cr.lon << ")";
  return s;
}

bool ClientRegion::operator==(const ClientRegion &other) {
  return (this->lat == other.lat && this->lon == other.lon);
}

// Arbitrary ordering
bool ClientRegion::operator>(const ClientRegion &other) {
  if (this->lat > other.lat) return true;
  if (this->lat == other.lat) {
    if (this->lon > other.lon) return true;
  }
  return false;
}

bool ClientRegion::operator<(const ClientRegion &other) {
  return (!(*this == other) && !(*this > other));
}

int ClientRegion::get_hash() {
  int out = 0;
  for (int i = 0; i < (2 * sizeof(int)); i++) {
    if (i < sizeof(int)) {
      out = out*31 + ((char*) &lat)[i];
    }
    else {
      out = out*31 + ((char*) &lon)[i - sizeof(int)];
    }
  } 
  return out;
}


// Functions for hash based sets
size_t ClientRegionEqual::operator()(
  const ClientRegion &cr1, const ClientRegion &cr2) const {
  ClientRegion& cr1_b = const_cast<ClientRegion&>(cr1);
  ClientRegion& cr2_b = const_cast<ClientRegion&>(cr2);
  return (cr1.lat == cr2.lat) && (cr1.lon == cr2.lon);
} 

size_t ClientRegionHash::operator()(const ClientRegion &cr) const {
  return const_cast<ClientRegion&>(cr).get_hash();
}

size_t SubdomainEqual::operator()(
  const SubdomainInfo &s1, const SubdomainInfo &s2) const {
  return (string(s1.storage.fqdn.cstr()) == string(s2.storage.fqdn.cstr()));
}

size_t SubdomainHash::operator()(const SubdomainInfo &s) const {
  size_t out = 0;
  const char* fqdn = s.storage.fqdn.cstr();
  for (int i = 0; i < strlen(fqdn); i++) {
    out = out * 31 + fqdn[i];
  }
  return out;
}

# 143 "resolver.T"
static void  get_client_region( string ip,  cb_cr cb, ptr<closure_t> __cls_g = NULL); 
# 143 "resolver.T"
class get_client_region__closure_t : public closure_t { public:   get_client_region__closure_t ( string ip,  cb_cr cb) : closure_t ("resolver.T", "get_client_region"),  _stack (ip, cb), _args (ip, cb) {}   void reenter ()   {     get_client_region (_args.ip, _args.cb, mkref (this));   } void v_reenter () { reenter (); }   struct stack_t {     stack_t ( string ip,  cb_cr cb) {}      Statement *st;      ResultSet *res;      float lat_f;      float lon_f;      int lat_d;      int lon_d;      int lat_d_rounded;      int lon_d_rounded;      struct in_addr addr;   };   struct args_t {     args_t ( string ip,  cb_cr cb) : ip (ip), cb (cb) {}      string ip;      cb_cr cb;   };   stack_t _stack;   args_t _args;   bool is_onstack (const void *p) const   {     return (static_cast<const void *> (&_stack) <= p &&             static_cast<const void *> (&_stack + 1) > p);   } }; 
# 143 "resolver.T"
void 
get_client_region( string __tame_ip,  cb_cr __tame_cb, ptr<closure_t> __cls_g)
{
# 143 "resolver.T"

  
# 144 "resolver.T"
  get_client_region__closure_t *__cls;   ptr<get_client_region__closure_t > __cls_r;   if (!__cls_g) {     if (tame_check_leaks ()) start_rendezvous_collection ();     __cls_r = New refcounted<get_client_region__closure_t> (__tame_ip, __tame_cb);     if (tame_check_leaks ()) __cls_r->collect_rendezvous ();     __cls = __cls_r;     __cls_g = __cls_r;   } else {     __cls =     reinterpret_cast<get_client_region__closure_t *> (static_cast<closure_t *> (__cls_g));     __cls_r = mkref (__cls);   }    Statement *&st = __cls->_stack.st;    ResultSet *&res = __cls->_stack.res;    float &lat_f = __cls->_stack.lat_f;    float &lon_f = __cls->_stack.lon_f;    int &lat_d = __cls->_stack.lat_d;    int &lon_d = __cls->_stack.lon_d;    int &lat_d_rounded = __cls->_stack.lat_d_rounded;    int &lon_d_rounded = __cls->_stack.lon_d_rounded;    struct in_addr &addr = __cls->_stack.addr;    string &ip = __cls->_args.ip;    cb_cr &cb = __cls->_args.cb;    use_reference (ip);     use_reference (cb);    switch (__cls->jumpto ()) {   case 0: break;   default:     panic ("unexpected case.\n");     break;   }
# 154 "resolver.T"

  if (debug) {
    cout << "Quova lookup requested for " << ip << endl;
    fflush(stdout);
  }
  // In cache?
  inet_aton(ip.c_str(), &addr);
  location_cache_it = location_cache.find(addr.s_addr);
  if (location_cache_it != location_cache.end()) {
    TRIGGER(cb, location_cache_it->second);
    
# 164 "resolver.T"
  do { __cls->end_of_scope_checks (164);
# 164 "resolver.T"
    return ;  } while (0);
  }
  st = quova_conn->createStatement();
  res = st->executeQuery("SELECT * FROM quova a WHERE a.start_ip_int = (\
    SELECT MAX(start_ip_int) FROM quova b\
    WHERE b.start_ip_int <= INET_ATON('" + ip + "'))\
    AND a.end_ip_int >= INET_ATON('" + ip + "');");

  lat_f = 0;
  lon_f = 0;

  while (res->next()) {
    lat_f = static_cast<float>(res->getInt("latitude"));
    lon_f = static_cast<float>(res->getInt("longitude"));
  }
  lat_d = static_cast<int>(lat_f);
  lon_d = static_cast<int>(lon_f);

  // Binning
  lat_d_rounded = lat_d - (lat_d % 5);
  lon_d_rounded = lon_d - (lon_d % 5);
 
  ClientRegion out = ClientRegion(lat_d_rounded, lon_d_rounded);

  if (location_cache.size() > 300) {
    location_cache.erase(location_cache.begin()->first);
  }
  
  location_cache.insert(pair<unsigned long, ClientRegion>(addr.s_addr, out));
  
  if (debug) {
    cout << "Returning client region from quova lookup: " <<  out << endl;
    fflush(stdout);
  }
  TRIGGER(cb, out);
# 199 "resolver.T"
  do {   __cls->end_of_scope_checks (196);   return;   } while (0);
# 196 "resolver.T"
}

// Given a subdomain and a client region, returns the closest n records,
// with the closest one first.
# 200 "resolver.T"
static void  closest_n_records( SubdomainInfo *sd,  ClientRegion *cr,  int n,  callback< void  ,  vector< record > >::ref cb, ptr<closure_t> __cls_g = NULL); 
# 200 "resolver.T"
class closest_n_records__closure_t : public closure_t { public:   closest_n_records__closure_t ( SubdomainInfo *sd,  ClientRegion *cr,  int n,  callback< void  ,  vector< record > >::ref cb) : closure_t ("resolver.T", "closest_n_records"),  _stack (sd, cr, n, cb), _args (sd, cr, n, cb) {}   void reenter ()   {     closest_n_records (_args.sd, _args.cr, _args.n, _args.cb, mkref (this));   } void v_reenter () { reenter (); }   struct stack_t {     stack_t ( SubdomainInfo *sd,  ClientRegion *cr,  int n,  callback< void  ,  vector< record > >::ref cb) {}      record rec;      multimap< int  ,  record > by_distance;      multimap< int  ,  record >::iterator by_distance_it;      int i;      vector< record > out;      ClientRegion other;   };   struct args_t {     args_t ( SubdomainInfo *sd,  ClientRegion *cr,  int n,  callback< void  ,  vector< record > >::ref cb) : sd (sd), cr (cr), n (n), cb (cb) {}      SubdomainInfo *sd;      ClientRegion *cr;      int n;      callback< void  ,  vector< record > >::ref cb;   };   stack_t _stack;   args_t _args;   bool is_onstack (const void *p) const   {     return (static_cast<const void *> (&_stack) <= p &&             static_cast<const void *> (&_stack + 1) > p);   } }; 
# 200 "resolver.T"
void 
closest_n_records( SubdomainInfo *__tame_sd,  ClientRegion *__tame_cr,  int __tame_n,  callback< void  ,  vector< record > >::ref __tame_cb, ptr<closure_t> __cls_g)
{
# 201 "resolver.T"

  
# 202 "resolver.T"
  closest_n_records__closure_t *__cls;   ptr<closest_n_records__closure_t > __cls_r;   if (!__cls_g) {     if (tame_check_leaks ()) start_rendezvous_collection ();     __cls_r = New refcounted<closest_n_records__closure_t> (__tame_sd, __tame_cr, __tame_n, __tame_cb);     if (tame_check_leaks ()) __cls_r->collect_rendezvous ();     __cls = __cls_r;     __cls_g = __cls_r;   } else {     __cls =     reinterpret_cast<closest_n_records__closure_t *> (static_cast<closure_t *> (__cls_g));     __cls_r = mkref (__cls);   }    record &rec = __cls->_stack.rec;    multimap< int  ,  record > &by_distance = __cls->_stack.by_distance;    multimap< int  ,  record >::iterator &by_distance_it = __cls->_stack.by_distance_it;    int &i = __cls->_stack.i;    vector< record > &out = __cls->_stack.out;    ClientRegion &other = __cls->_stack.other;    SubdomainInfo *&sd = __cls->_args.sd;    ClientRegion *&cr = __cls->_args.cr;    int &n = __cls->_args.n;    callback< void  ,  vector< record > >::ref &cb = __cls->_args.cb;    use_reference (sd);     use_reference (cr);     use_reference (n);     use_reference (cb);    switch (__cls->jumpto ()) {   case 0: break;   case 1:     goto closest_n_records__label_1;     break;   default:     panic ("unexpected case.\n");     break;   }
# 209 "resolver.T"

  for (i = 0; i < sd->storage.records.size(); i++) {
    rec = sd->storage.records[i];
    
# 212 "resolver.T"
  do {     do {       closure_wrapper<closest_n_records__closure_t > __cls_g (__cls_r);     __cls->init_block (1, 212);     __cls->set_jumpto (1); 
# 212 "resolver.T"
get_client_region(rec.content.cstr(), mkevent(other));
# 212 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  closest_n_records__label_1:       ;   } while (0);
# 212 "resolver.T"

    int distance = ((cr->lat - other.lat) * (cr->lat - other.lat)) +
      ((cr->lon - other.lon) * (cr->lon - other.lon));
    by_distance.insert(pair<int, record>(distance, rec));
  }
  by_distance_it = by_distance.begin();
  for (i = 0; (i < by_distance.size()) && (i < n); i++) {
    out.push_back(by_distance_it->second);
    by_distance_it++;
  }
  TRIGGER(cb, out);
# 223 "resolver.T"
  do {   __cls->end_of_scope_checks (223);   return;   } while (0);
# 223 "resolver.T"
}

void print_request_logs(SubdomainInfo* sd) {
  client_requests_iter it = sd->num_requests.begin();
  cout << sd->storage.fqdn << endl;
  while (it != sd->num_requests.end()) { 
    ClientRegion r = it->first;
    cout << r << endl;
    unordered_map<size_t, unsigned int>* map = it->second;
    num_request_iter t_it = map->begin();
    while (t_it != map->end()) {
      cout << t_it->first << ": " << t_it->second << endl;
      ++t_it;
    }
    ++it;
  }
  fflush(stdout);
}

// Delete old records so we don't fill up too much memory
void clean_request_logs() {
  subdomain_cache_it = subdomain_cache.begin();
  size_t cutoff_time = time(NULL) - (60 * LOG_EXPIRY_MINUTES);
  while (subdomain_cache_it != subdomain_cache.end()) {
    SubdomainInfo* sd = const_cast<SubdomainInfo*>(&*subdomain_cache_it);
    client_requests_iter it = sd->num_requests.begin();
    while (it != sd->num_requests.end()) {
      unordered_map<size_t, unsigned int>* map = it->second;
      num_request_iter t_it = map->begin();
      while (t_it != map->end()) {
        if (t_it->first < cutoff_time) 
          map->erase(t_it->first);           
        t_it++;
      }
      it++;
    }
    subdomain_cache_it++;
  }
  delaycb(LOG_CLEAN_INTERVAL_MINS * 60, 0, wrap(clean_request_logs));
}

// Increments various counters which record request volume and client space.
void log_client_request(ClientRegion* c, SubdomainInfo* sd) {
  // Assure we're storing this client region for this subdomain
  client_requests_iter it = sd->num_requests.find(*c);
  if (it == sd->num_requests.end()) {
    unordered_map<size_t, unsigned int> *new_map = 
      new unordered_map<size_t, unsigned int>;
    sd->num_requests.insert(
      pair<ClientRegion, unordered_map<size_t, unsigned int>* >(*c, new_map));
    it = sd->num_requests.find(*c);
  }
  unordered_map<size_t, unsigned int>* existing_map = it->second;
size_t t = time(NULL);

  t = t - (t % 60); // Request granularity is per-minute

  // Add this request to the log for this minute
  num_request_iter t_it = existing_map->find(t);
  
  if (t_it == existing_map->end()) {
    existing_map->insert(pair<size_t, unsigned int>(t, 1));
  }
  else {
    if (debug) cout << "Updating Value\n";
    unsigned int value = t_it->second;
    existing_map->erase(t);
    existing_map->insert(pair<size_t, unsigned int>(t, value + 1));
  }
}

// Sets the optimization data described by sd_opt in craq
# 295 "resolver.T"
class SubdomainInfo__set_opt_data__closure_t : public closure_t { public:   SubdomainInfo__set_opt_data__closure_t (SubdomainInfo *_self,  struct subdomain_opt sd_opt,  callback< void >::ref cb) : closure_t ("resolver.T", "SubdomainInfo::set_opt_data"), _self (_self),  _stack (_self, sd_opt, cb), _args (sd_opt, cb) {}   typedef void  (SubdomainInfo::*method_type_t) ( struct subdomain_opt ,  callback< void >::ref , ptr<closure_t>);   void set_method_pointer (method_type_t m) { _method = m; }   void reenter ()   {     ((*_self).*_method)  (_args.sd_opt, _args.cb, mkref (this));   } void v_reenter () { reenter (); }   struct stack_t {     stack_t (SubdomainInfo *_self,  struct subdomain_opt sd_opt,  callback< void >::ref cb) {}      str subdomain_data;      string result;      string opt_key;   };   struct args_t {     args_t ( struct subdomain_opt sd_opt,  callback< void >::ref cb) : sd_opt (sd_opt), cb (cb) {}      struct subdomain_opt sd_opt;      callback< void >::ref cb;   };   SubdomainInfo *_self;   stack_t _stack;   args_t _args;   method_type_t _method;   bool is_onstack (const void *p) const   {     return (static_cast<const void *> (&_stack) <= p &&             static_cast<const void *> (&_stack + 1) > p);   } }; 
# 295 "resolver.T"
void 
SubdomainInfo::set_opt_data( struct subdomain_opt __tame_sd_opt,  callback< void >::ref __tame_cb, ptr<closure_t> __cls_g)
{
# 296 "resolver.T"

  
# 297 "resolver.T"
  SubdomainInfo__set_opt_data__closure_t *__cls;   ptr<SubdomainInfo__set_opt_data__closure_t > __cls_r;   if (!__cls_g) {     if (tame_check_leaks ()) start_rendezvous_collection ();     __cls_r = New refcounted<SubdomainInfo__set_opt_data__closure_t> (this, __tame_sd_opt, __tame_cb);     if (tame_check_leaks ()) __cls_r->collect_rendezvous ();     __cls = __cls_r;     __cls_g = __cls_r;     __cls->set_method_pointer (&SubdomainInfo::set_opt_data);   } else {     __cls =     reinterpret_cast<SubdomainInfo__set_opt_data__closure_t *> (static_cast<closure_t *> (__cls_g));     __cls_r = mkref (__cls);   }    str &subdomain_data = __cls->_stack.subdomain_data;    string &result = __cls->_stack.result;    string &opt_key = __cls->_stack.opt_key;    struct subdomain_opt &sd_opt = __cls->_args.sd_opt;    callback< void >::ref &cb = __cls->_args.cb;    use_reference (sd_opt);     use_reference (cb);    switch (__cls->jumpto ()) {   case 0: break;   case 1:     goto SubdomainInfo__set_opt_data__label_1;     break;   default:     panic ("unexpected case.\n");     break;   }
# 301 "resolver.T"

  subdomain_data = xdr2str(sd_opt);
  opt_key = this->storage.fqdn.cstr();
  opt_key += "-opt";
  if (debug) cout << "Updating optimization values for " << opt_key;
  
# 306 "resolver.T"
  do {     do {       closure_wrapper<SubdomainInfo__set_opt_data__closure_t > __cls_g (__cls_r);     __cls->init_block (1, 306);     __cls->set_jumpto (1); 
# 306 "resolver.T"
craq.set_key(opt_key, subdomain_data.cstr(), subdomain_data.len(),
    mkevent(result));
# 307 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  SubdomainInfo__set_opt_data__label_1:       ;   } while (0);
# 307 "resolver.T"

  TRIGGER(cb);
# 309 "resolver.T"
  do {   __cls->end_of_scope_checks (309);   return;   } while (0);
# 309 "resolver.T"
}

// Gets optimization data from CRAQ for this subdomain. If no optimization
// record exists in CRAQ, creates one. 
# 313 "resolver.T"
class SubdomainInfo__get_opt_data__closure_t : public closure_t { public:   SubdomainInfo__get_opt_data__closure_t (SubdomainInfo *_self,  callback< void  ,  subdomain_opt >::ref cb) : closure_t ("resolver.T", "SubdomainInfo::get_opt_data"), _self (_self),  _stack (_self, cb), _args (cb) {}   typedef void  (SubdomainInfo::*method_type_t) ( callback< void  ,  subdomain_opt >::ref , ptr<closure_t>);   void set_method_pointer (method_type_t m) { _method = m; }   void reenter ()   {     ((*_self).*_method)  (_args.cb, mkref (this));   } void v_reenter () { reenter (); }   struct stack_t {     stack_t (SubdomainInfo *_self,  callback< void  ,  subdomain_opt >::ref cb) {}      string opt_key;      str subdomain_data;      subdomain_opt sd_opt;      rec_opt_info new_rec_opt;      int i;      int j;      double proportion;      double lambda;      double epsilon;   };   struct args_t {     args_t ( callback< void  ,  subdomain_opt >::ref cb) : cb (cb) {}      callback< void  ,  subdomain_opt >::ref cb;   };   SubdomainInfo *_self;   stack_t _stack;   args_t _args;   method_type_t _method;   bool is_onstack (const void *p) const   {     return (static_cast<const void *> (&_stack) <= p &&             static_cast<const void *> (&_stack + 1) > p);   } }; 
# 313 "resolver.T"
void 
SubdomainInfo::get_opt_data( callback< void  ,  subdomain_opt >::ref __tame_cb, ptr<closure_t> __cls_g)
{
# 313 "resolver.T"

  
# 314 "resolver.T"
  SubdomainInfo__get_opt_data__closure_t *__cls;   ptr<SubdomainInfo__get_opt_data__closure_t > __cls_r;   if (!__cls_g) {     if (tame_check_leaks ()) start_rendezvous_collection ();     __cls_r = New refcounted<SubdomainInfo__get_opt_data__closure_t> (this, __tame_cb);     if (tame_check_leaks ()) __cls_r->collect_rendezvous ();     __cls = __cls_r;     __cls_g = __cls_r;     __cls->set_method_pointer (&SubdomainInfo::get_opt_data);   } else {     __cls =     reinterpret_cast<SubdomainInfo__get_opt_data__closure_t *> (static_cast<closure_t *> (__cls_g));     __cls_r = mkref (__cls);   }    string &opt_key = __cls->_stack.opt_key;    str &subdomain_data = __cls->_stack.subdomain_data;    subdomain_opt &sd_opt = __cls->_stack.sd_opt;    rec_opt_info &new_rec_opt = __cls->_stack.new_rec_opt;    int &i = __cls->_stack.i;    int &j = __cls->_stack.j;    double &proportion = __cls->_stack.proportion;    double &lambda = __cls->_stack.lambda;    double &epsilon = __cls->_stack.epsilon;    callback< void  ,  subdomain_opt >::ref &cb = __cls->_args.cb;    use_reference (cb);    switch (__cls->jumpto ()) {   case 0: break;   case 1:     goto SubdomainInfo__get_opt_data__label_1;     break;   default:     panic ("unexpected case.\n");     break;   }
# 321 "resolver.T"


  opt_key = this->storage.fqdn.cstr();
  opt_key += "-opt";
  
# 325 "resolver.T"
  do {     do {       closure_wrapper<SubdomainInfo__get_opt_data__closure_t > __cls_g (__cls_r);     __cls->init_block (1, 325);     __cls->set_jumpto (1); 
# 325 "resolver.T"
craq.get_key(opt_key, mkevent(subdomain_data));
# 325 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  SubdomainInfo__get_opt_data__label_1:       ;   } while (0);
# 325 "resolver.T"


  if (subdomain_data.len() > 20) {
    str2xdr (sd_opt, subdomain_data);
  }
  if (subdomain_data.len() < 20 || 
       (sd_opt.records.size() != this->storage.records.size()) ||
       (sd_opt.seq_number < this->storage.seq_number)) {
      if (debug) cout << "CRAQ does not have updated optimization info for \n" 
        << this->storage.fqdn.cstr();

      // Add new entries for existing records
      sd_opt.seq_number = this->storage.seq_number;
      sd_opt.fqdn = this->storage.fqdn;
      sd_opt.records.setsize(0);
      for (i=0; i < this->storage.records.size(); i++) {
        new_rec_opt.content = this->storage.records[i].content;
        proportion =  1.0 / this->storage.records.size();
        epsilon = .02;
        for (j=0; j < this->storage.records[i].attrs.size(); j++) {
          if (this->storage.records[i].attrs[j].type == SPLIT_PROPORTION) {
            memcpy(&proportion, &this->storage.records[i].attrs[j].data, 
                   sizeof(double));
          }  
          if (this->storage.records[i].attrs[j].type == SPLIT_EPSILON) {
            memcpy(&proportion, &this->storage.records[i].attrs[j].data,
                   sizeof(double));
          } 
        }
        lambda = 1.0;
        memcpy(&new_rec_opt.proportion, &proportion, 
          sizeof(new_rec_opt.proportion));
        memcpy(&new_rec_opt.epsilon, &epsilon, sizeof(new_rec_opt.epsilon));
        memcpy(&new_rec_opt.lambda, &lambda, sizeof(new_rec_opt.lambda));

        sd_opt.records.push_back(new_rec_opt);
        if (debug) cout << sd_opt.records.size();
        if (debug) cout << this->storage.records.size();
      }
  }
  if (this->storage.records.size() != sd_opt.records.size()) {
    exit(1);
  }

  TRIGGER(cb, sd_opt);
# 370 "resolver.T"
  do {   __cls->end_of_scope_checks (370);   return;   } while (0);
# 370 "resolver.T"
}

// Get the toal traffic this node expects to route to each record
# 373 "resolver.T"
class SubdomainInfo__get_my_totals__closure_t : public closure_t { public:   SubdomainInfo__get_my_totals__closure_t (SubdomainInfo *_self,  int minutes,  callback< void  ,  vector< pair< record  ,  double > >  ,  double >::ref cb) : closure_t ("resolver.T", "SubdomainInfo::get_my_totals"), _self (_self),  _stack (_self, minutes, cb), _args (minutes, cb) {}   typedef void  (SubdomainInfo::*method_type_t) ( int ,  callback< void  ,  vector< pair< record  ,  double > >  ,  double >::ref , ptr<closure_t>);   void set_method_pointer (method_type_t m) { _method = m; }   void reenter ()   {     ((*_self).*_method)  (_args.minutes, _args.cb, mkref (this));   } void v_reenter () { reenter (); }   struct stack_t {     stack_t (SubdomainInfo *_self,  int minutes,  callback< void  ,  vector< pair< record  ,  double > >  ,  double >::ref cb) {}      client_requests_iter client_it;      size_t now;      vector< pair< record  ,  double > > to_add;      vector< pair< record  ,  double > >::iterator to_add_it;      num_request_iter time_it;      unordered_map< size_t  ,  unsigned int > *requests;      int i;      int j;      rules_iter rules_it;      client_rule_iter c_rule_it;      vector< record > recs;      double my_total;   };   struct args_t {     args_t ( int minutes,  callback< void  ,  vector< pair< record  ,  double > >  ,  double >::ref cb) : minutes (minutes), cb (cb) {}      int minutes;      callback< void  ,  vector< pair< record  ,  double > >  ,  double >::ref cb;   };   SubdomainInfo *_self;   stack_t _stack;   args_t _args;   method_type_t _method;   bool is_onstack (const void *p) const   {     return (static_cast<const void *> (&_stack) <= p &&             static_cast<const void *> (&_stack + 1) > p);   } }; 
# 373 "resolver.T"
void 
SubdomainInfo::get_my_totals( int __tame_minutes,  callback< void  ,  vector< pair< record  ,  double > >  ,  double >::ref __tame_cb, ptr<closure_t> __cls_g)
{
# 373 "resolver.T"

  
# 374 "resolver.T"
  SubdomainInfo__get_my_totals__closure_t *__cls;   ptr<SubdomainInfo__get_my_totals__closure_t > __cls_r;   if (!__cls_g) {     if (tame_check_leaks ()) start_rendezvous_collection ();     __cls_r = New refcounted<SubdomainInfo__get_my_totals__closure_t> (this, __tame_minutes, __tame_cb);     if (tame_check_leaks ()) __cls_r->collect_rendezvous ();     __cls = __cls_r;     __cls_g = __cls_r;     __cls->set_method_pointer (&SubdomainInfo::get_my_totals);   } else {     __cls =     reinterpret_cast<SubdomainInfo__get_my_totals__closure_t *> (static_cast<closure_t *> (__cls_g));     __cls_r = mkref (__cls);   }    client_requests_iter &client_it = __cls->_stack.client_it;    size_t &now = __cls->_stack.now;    vector< pair< record  ,  double > > &to_add = __cls->_stack.to_add;    vector< pair< record  ,  double > >::iterator &to_add_it = __cls->_stack.to_add_it;    num_request_iter &time_it = __cls->_stack.time_it;    unordered_map< size_t  ,  unsigned int > *&requests = __cls->_stack.requests;    int &i = __cls->_stack.i;    int &j = __cls->_stack.j;    rules_iter &rules_it = __cls->_stack.rules_it;    client_rule_iter &c_rule_it = __cls->_stack.c_rule_it;    vector< record > &recs = __cls->_stack.recs;    double &my_total = __cls->_stack.my_total;    int &minutes = __cls->_args.minutes;    callback< void  ,  vector< pair< record  ,  double > >  ,  double >::ref &cb = __cls->_args.cb;    use_reference (minutes);     use_reference (cb);    switch (__cls->jumpto ()) {   case 0: break;   case 1:     goto SubdomainInfo__get_my_totals__label_1;     break;   default:     panic ("unexpected case.\n");     break;   }
# 386 "resolver.T"

  client_it = this->num_requests.begin();
  now = time(NULL);
  my_total = 0.0;
  // Populate record list with blanks
  for (i=0; i < this->storage.records.size(); i++) {
    to_add.push_back(pair<record, double> (this->storage.records[i], 0.0));
  }

  // Iterate through client regions
  while (client_it != this->num_requests.end()) {
    requests = client_it->second;
    rules_it = this->rules.find(client_it->first);
    if (rules_it == this->rules.end()) {
      // If we don't have any rules, we must be mapping to closest node
      // so store expected traffic as if mapping to closest node
      
# 402 "resolver.T"
  do {     do {       closure_wrapper<SubdomainInfo__get_my_totals__closure_t > __cls_g (__cls_r);     __cls->init_block (1, 402);     __cls->set_jumpto (1); 
# 402 "resolver.T"
closest_n_records(this, const_cast<ClientRegion*>(
        &(client_it->first)), 1, mkevent(recs));
# 403 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  SubdomainInfo__get_my_totals__label_1:       ;   } while (0);
# 403 "resolver.T"

      if (recs.size() == 0) {
        client_it++;
        continue;
      }
      time_it = requests->begin();

      while (time_it != requests->end()) {
        if (time_it->first > (now - (minutes * 60))) {
          to_add_it = to_add.begin();
          while (to_add_it != to_add.end()) {
            if (recs[0].content == to_add_it->first.content ) {
              to_add_it->second += 1.0 * time_it->second;
              my_total += 1.0 * time_it->second;
            }
            to_add_it++;
          }
        }
        time_it++;
      }
      client_it++;
      continue;
    }
    // We have rules for this cleint...
    time_it = requests->begin();
    while(time_it != requests->end()) {
      // Do we consider this time-period?
      if (time_it->first > (now - (minutes * 60))) {
        // For each record add the expected traffic from this client
        // group.
        to_add_it = to_add.begin();
        while (to_add_it != to_add.end()) {
          c_rule_it = rules_it->second.begin();
          while (c_rule_it != rules_it->second.end()) {
           if (c_rule_it->first.content == to_add_it->first.content ) {
              to_add_it->second += c_rule_it->second * time_it->second;
              my_total += c_rule_it->second * time_it->second;
            }
            c_rule_it++;
          }
          to_add_it++;
        }
      }
      time_it++;
    }
    client_it++;
  }

  TRIGGER(cb, to_add, my_total);
# 452 "resolver.T"
  do {   __cls->end_of_scope_checks (452);   return;   } while (0);
# 452 "resolver.T"
}

// Take traffic over the last <minutes> minutes, and calculate the
// expected traffic load on each server given the current routing policy.
# 456 "resolver.T"
class SubdomainInfo__update_expected_traffic__closure_t : public closure_t { public:   SubdomainInfo__update_expected_traffic__closure_t (SubdomainInfo *_self,  int minutes,  callback< void >::ref cb) : closure_t ("resolver.T", "SubdomainInfo::update_expected_traffic"), _self (_self),  _stack (_self, minutes, cb), _args (minutes, cb) {}   typedef void  (SubdomainInfo::*method_type_t) ( int ,  callback< void >::ref , ptr<closure_t>);   void set_method_pointer (method_type_t m) { _method = m; }   void reenter ()   {     ((*_self).*_method)  (_args.minutes, _args.cb, mkref (this));   } void v_reenter () { reenter (); }   struct stack_t {     stack_t (SubdomainInfo *_self,  int minutes,  callback< void >::ref cb) {}      size_t now;      client_requests_iter client_it;      unordered_map< size_t  ,  unsigned int > *requests;      vector< pair< record  ,  double > > to_add;      vector< pair< record  ,  double > >::iterator to_add_it;      num_request_iter time_it;      rules_iter rules_it;      client_rule_iter c_rule_it;      vector< pair< record  ,  float > > rules;      str subdomain_data;      struct subdomain_opt sd_opt;      int i;      int j;      bool seen;      string opt_key;      string result;      struct traffic_entry new_entry;      vector< record > recs;      double unused;   };   struct args_t {     args_t ( int minutes,  callback< void >::ref cb) : minutes (minutes), cb (cb) {}      int minutes;      callback< void >::ref cb;   };   SubdomainInfo *_self;   stack_t _stack;   args_t _args;   method_type_t _method;   bool is_onstack (const void *p) const   {     return (static_cast<const void *> (&_stack) <= p &&             static_cast<const void *> (&_stack + 1) > p);   } }; 
# 456 "resolver.T"
void 
SubdomainInfo::update_expected_traffic( int __tame_minutes,  callback< void >::ref __tame_cb, ptr<closure_t> __cls_g)
{
# 457 "resolver.T"

  
# 458 "resolver.T"
  SubdomainInfo__update_expected_traffic__closure_t *__cls;   ptr<SubdomainInfo__update_expected_traffic__closure_t > __cls_r;   if (!__cls_g) {     if (tame_check_leaks ()) start_rendezvous_collection ();     __cls_r = New refcounted<SubdomainInfo__update_expected_traffic__closure_t> (this, __tame_minutes, __tame_cb);     if (tame_check_leaks ()) __cls_r->collect_rendezvous ();     __cls = __cls_r;     __cls_g = __cls_r;     __cls->set_method_pointer (&SubdomainInfo::update_expected_traffic);   } else {     __cls =     reinterpret_cast<SubdomainInfo__update_expected_traffic__closure_t *> (static_cast<closure_t *> (__cls_g));     __cls_r = mkref (__cls);   }    size_t &now = __cls->_stack.now;    client_requests_iter &client_it = __cls->_stack.client_it;    unordered_map< size_t  ,  unsigned int > *&requests = __cls->_stack.requests;    vector< pair< record  ,  double > > &to_add = __cls->_stack.to_add;    vector< pair< record  ,  double > >::iterator &to_add_it = __cls->_stack.to_add_it;    num_request_iter &time_it = __cls->_stack.time_it;    rules_iter &rules_it = __cls->_stack.rules_it;    client_rule_iter &c_rule_it = __cls->_stack.c_rule_it;    vector< pair< record  ,  float > > &rules = __cls->_stack.rules;    str &subdomain_data = __cls->_stack.subdomain_data;    struct subdomain_opt &sd_opt = __cls->_stack.sd_opt;    int &i = __cls->_stack.i;    int &j = __cls->_stack.j;    bool &seen = __cls->_stack.seen;    string &opt_key = __cls->_stack.opt_key;    string &result = __cls->_stack.result;    struct traffic_entry &new_entry = __cls->_stack.new_entry;    vector< record > &recs = __cls->_stack.recs;    double &unused = __cls->_stack.unused;    int &minutes = __cls->_args.minutes;    callback< void >::ref &cb = __cls->_args.cb;    use_reference (minutes);     use_reference (cb);    switch (__cls->jumpto ()) {   case 0: break;   case 1:     goto SubdomainInfo__update_expected_traffic__label_1;     break;   case 2:     goto SubdomainInfo__update_expected_traffic__label_2;     break;   case 3:     goto SubdomainInfo__update_expected_traffic__label_3;     break;   default:     panic ("unexpected case.\n");     break;   }
# 476 "resolver.T"

  
  
# 478 "resolver.T"
  do {     do {       closure_wrapper<SubdomainInfo__update_expected_traffic__closure_t > __cls_g (__cls_r);     __cls->init_block (1, 478);     __cls->set_jumpto (1); 
# 478 "resolver.T"
this->get_my_totals(minutes, mkevent(to_add, unused));
# 478 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  SubdomainInfo__update_expected_traffic__label_1:       ;   } while (0);
# 478 "resolver.T"

  
# 479 "resolver.T"
  do {     do {       closure_wrapper<SubdomainInfo__update_expected_traffic__closure_t > __cls_g (__cls_r);     __cls->init_block (2, 479);     __cls->set_jumpto (2); 
# 479 "resolver.T"
this->get_opt_data(mkevent(sd_opt)); 
# 479 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  SubdomainInfo__update_expected_traffic__label_2:       ;   } while (0);
# 479 "resolver.T"

  
  to_add_it = to_add.begin();

  // Look at each record in the optimization entry
  for (i=0; i < sd_opt.records.size(); i++) {
    to_add_it = to_add.begin();
    // Now see if we have a traffic value for this record
    while (to_add_it != to_add.end()) {
      if (sd_opt.records[i].content == to_add_it->first.content) {
        // We have something to add, so add it...
        for (j=0; j<sd_opt.records[i].entries.size(); j++) {
          if (sd_opt.records[i].entries[j].server_id == my_ip_addr) {
            sd_opt.records[i].entries[j].update_time = time(NULL);
            memcpy(&sd_opt.records[i].entries[j].traffic_vol,
              &to_add_it->second, sizeof(double));
            seen = true;
          }
        }
        if (seen == false) {
          new_entry.server_id = my_ip_addr;
          new_entry.update_time = time(NULL);
          memcpy(&new_entry.traffic_vol, &to_add_it->second, sizeof(double));
          sd_opt.records[i].entries.push_back(new_entry);
        }
        seen = false;
      }
      to_add_it++;
    }
  }

  
# 510 "resolver.T"
  do {     do {       closure_wrapper<SubdomainInfo__update_expected_traffic__closure_t > __cls_g (__cls_r);     __cls->init_block (3, 510);     __cls->set_jumpto (3); 
# 510 "resolver.T"
 this->set_opt_data(sd_opt, mkevent()); 
# 510 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  SubdomainInfo__update_expected_traffic__label_3:       ;   } while (0);
# 510 "resolver.T"


  // Print out totals
  to_add_it = to_add.begin();
  if (debug) {
    cout << "Totals\n:";
    while (to_add_it != to_add.end()) {
      cout << to_add_it->first.content;
      cout << " ";
      cout << to_add_it->second;
      cout << "\n";
      to_add_it++;
    }
  }
  TRIGGER(cb);
# 525 "resolver.T"
  do {   __cls->end_of_scope_checks (525);   return;   } while (0);
# 525 "resolver.T"
}

// Given an struct subdomain_opt add up the total traffic to each instance.
// If include_me is true, the instance map includes traffic
// from this node.
# 530 "resolver.T"
class SubdomainInfo__get_traffic_totals__closure_t : public closure_t { public:   SubdomainInfo__get_traffic_totals__closure_t (SubdomainInfo *_self,  struct subdomain_opt sd_opt,  bool include_me,  cb_totals cb) : closure_t ("resolver.T", "SubdomainInfo::get_traffic_totals"), _self (_self),  _stack (_self, sd_opt, include_me, cb), _args (sd_opt, include_me, cb) {}   typedef void  (SubdomainInfo::*method_type_t) ( struct subdomain_opt ,  bool ,  cb_totals , ptr<closure_t>);   void set_method_pointer (method_type_t m) { _method = m; }   void reenter ()   {     ((*_self).*_method)  (_args.sd_opt, _args.include_me, _args.cb, mkref (this));   } void v_reenter () { reenter (); }   struct stack_t {     stack_t (SubdomainInfo *_self,  struct subdomain_opt sd_opt,  bool include_me,  cb_totals cb) {}      unordered_map< string  ,  double > out;      string opt_key;      str subdomain_data;      int i;      int j;      double temp;      double other_instance_total;      double instance_total;      double subdomain_total;   };   struct args_t {     args_t ( struct subdomain_opt sd_opt,  bool include_me,  cb_totals cb) : sd_opt (sd_opt), include_me (include_me), cb (cb) {}      struct subdomain_opt sd_opt;      bool include_me;      cb_totals cb;   };   SubdomainInfo *_self;   stack_t _stack;   args_t _args;   method_type_t _method;   bool is_onstack (const void *p) const   {     return (static_cast<const void *> (&_stack) <= p &&             static_cast<const void *> (&_stack + 1) > p);   } }; 
# 530 "resolver.T"
void 
SubdomainInfo::get_traffic_totals( struct subdomain_opt __tame_sd_opt,  bool __tame_include_me,  cb_totals __tame_cb, ptr<closure_t> __cls_g)
{
# 531 "resolver.T"

  
# 532 "resolver.T"
  SubdomainInfo__get_traffic_totals__closure_t *__cls;   ptr<SubdomainInfo__get_traffic_totals__closure_t > __cls_r;   if (!__cls_g) {     if (tame_check_leaks ()) start_rendezvous_collection ();     __cls_r = New refcounted<SubdomainInfo__get_traffic_totals__closure_t> (this, __tame_sd_opt, __tame_include_me, __tame_cb);     if (tame_check_leaks ()) __cls_r->collect_rendezvous ();     __cls = __cls_r;     __cls_g = __cls_r;     __cls->set_method_pointer (&SubdomainInfo::get_traffic_totals);   } else {     __cls =     reinterpret_cast<SubdomainInfo__get_traffic_totals__closure_t *> (static_cast<closure_t *> (__cls_g));     __cls_r = mkref (__cls);   }    unordered_map< string  ,  double > &out = __cls->_stack.out;    string &opt_key = __cls->_stack.opt_key;    str &subdomain_data = __cls->_stack.subdomain_data;    int &i = __cls->_stack.i;    int &j = __cls->_stack.j;    double &temp = __cls->_stack.temp;    double &other_instance_total = __cls->_stack.other_instance_total;    double &instance_total = __cls->_stack.instance_total;    double &subdomain_total = __cls->_stack.subdomain_total;    struct subdomain_opt &sd_opt = __cls->_args.sd_opt;    bool &include_me = __cls->_args.include_me;    cb_totals &cb = __cls->_args.cb;    use_reference (sd_opt);     use_reference (include_me);     use_reference (cb);    switch (__cls->jumpto ()) {   case 0: break;   default:     panic ("unexpected case.\n");     break;   }
# 542 "resolver.T"


  subdomain_total = 0.0;

  for (i=0; i < sd_opt.records.size(); i++) {
    other_instance_total = 0;
    instance_total = 0;
    // Sum contribution from all nodes
    for (j=0; j < sd_opt.records[i].entries.size(); j++) {
      memcpy(&temp, &sd_opt.records[i].entries[j].traffic_vol, sizeof(double));
      instance_total += temp;
      if (debug) cout << "Adding: " << temp << "\n";
      if (include_me ||
        (sd_opt.records[i].entries[j].server_id != my_ip_addr)) {
        other_instance_total += temp;
      }
    }
    subdomain_total += instance_total;
    if (debug) {
      cout << "Adding the total for record: " << 
        sd_opt.records[i].content.cstr() << " " << other_instance_total << "\n";
    }

    out.insert(pair <string, double> (
      string(sd_opt.records[i].content.cstr()), other_instance_total));
  }
  if (debug) cout << "Total traffic was " << subdomain_total;
  TRIGGER(cb, out, subdomain_total);
# 570 "resolver.T"
  do {   __cls->end_of_scope_checks (570);   return;   } while (0);
# 570 "resolver.T"
}

static void MSKAPI printstr(void *handle, char str[]) {
  exit(1);
  printf("%s", str);
  fflush(stdout);
}

// Use traffic from other nodes, alongside local client information, to
// calculate optimal routes.
# 580 "resolver.T"
class SubdomainInfo__calculate_optimal_routes__closure_t : public closure_t { public:   SubdomainInfo__calculate_optimal_routes__closure_t (SubdomainInfo *_self,  callback< void >::ref cb) : closure_t ("resolver.T", "SubdomainInfo::calculate_optimal_routes"), _self (_self),  _stack (_self, cb), _args (cb) {}   typedef void  (SubdomainInfo::*method_type_t) ( callback< void >::ref , ptr<closure_t>);   void set_method_pointer (method_type_t m) { _method = m; }   void reenter ()   {     ((*_self).*_method)  (_args.cb, mkref (this));   } void v_reenter () { reenter (); }   struct stack_t {     stack_t (SubdomainInfo *_self,  callback< void >::ref cb) {}      vector< pair< ClientRegion  ,  float > > props;      vector< pair< ClientRegion  ,  float > >::iterator it;      int num_clients;      int num_servers;      ClientRegion other;      ClientRegion cr;      vector< float > coeffs;      subdomain_opt sd_opt;      int i;      int j;      int k;      int l;      int distance;      float distance_norm;      int problem_size;      int temp_index;      vector< double > temp_row;      vector< pair< record  ,  double > > unused;      double *solution;      unordered_map< ClientRegion  ,  vector< pair< record  ,  float > >  ,  ClientRegionHash  ,  ClientRegionEqual > new_rules;      vector< pair< record  ,  float > > client_rules;      MSKenv_t env;      MSKsolstae solsta;      MSKrescodee r;      MSKtask_t task;      MSKrescodee trmcode;      double temp;      double S_n;      double P_other;      double P_i;      double lambda;      double proportion;      double epsilon;      double diff;      double *result;      double update_prob;      unordered_map< string  ,  double > totals;      unordered_map< string  ,  double >::iterator totals_it;      double total_traffic;   };   struct args_t {     args_t ( callback< void >::ref cb) : cb (cb) {}      callback< void >::ref cb;   };   SubdomainInfo *_self;   stack_t _stack;   args_t _args;   method_type_t _method;   bool is_onstack (const void *p) const   {     return (static_cast<const void *> (&_stack) <= p &&             static_cast<const void *> (&_stack + 1) > p);   } }; 
# 580 "resolver.T"
void 
SubdomainInfo::calculate_optimal_routes( callback< void >::ref __tame_cb, ptr<closure_t> __cls_g)
{
# 580 "resolver.T"

  
# 581 "resolver.T"
  SubdomainInfo__calculate_optimal_routes__closure_t *__cls;   ptr<SubdomainInfo__calculate_optimal_routes__closure_t > __cls_r;   if (!__cls_g) {     if (tame_check_leaks ()) start_rendezvous_collection ();     __cls_r = New refcounted<SubdomainInfo__calculate_optimal_routes__closure_t> (this, __tame_cb);     if (tame_check_leaks ()) __cls_r->collect_rendezvous ();     __cls = __cls_r;     __cls_g = __cls_r;     __cls->set_method_pointer (&SubdomainInfo::calculate_optimal_routes);   } else {     __cls =     reinterpret_cast<SubdomainInfo__calculate_optimal_routes__closure_t *> (static_cast<closure_t *> (__cls_g));     __cls_r = mkref (__cls);   }    vector< pair< ClientRegion  ,  float > > &props = __cls->_stack.props;    vector< pair< ClientRegion  ,  float > >::iterator &it = __cls->_stack.it;    int &num_clients = __cls->_stack.num_clients;    int &num_servers = __cls->_stack.num_servers;    ClientRegion &other = __cls->_stack.other;    ClientRegion &cr = __cls->_stack.cr;    vector< float > &coeffs = __cls->_stack.coeffs;    subdomain_opt &sd_opt = __cls->_stack.sd_opt;    int &i = __cls->_stack.i;    int &j = __cls->_stack.j;    int &k = __cls->_stack.k;    int &l = __cls->_stack.l;    int &distance = __cls->_stack.distance;    float &distance_norm = __cls->_stack.distance_norm;    int &problem_size = __cls->_stack.problem_size;    int &temp_index = __cls->_stack.temp_index;    vector< double > &temp_row = __cls->_stack.temp_row;    vector< pair< record  ,  double > > &unused = __cls->_stack.unused;    double *&solution = __cls->_stack.solution;    unordered_map< ClientRegion  ,  vector< pair< record  ,  float > >  ,  ClientRegionHash  ,  ClientRegionEqual > &new_rules = __cls->_stack.new_rules;    vector< pair< record  ,  float > > &client_rules = __cls->_stack.client_rules;    MSKenv_t &env = __cls->_stack.env;    MSKsolstae &solsta = __cls->_stack.solsta;    MSKrescodee &r = __cls->_stack.r;    MSKtask_t &task = __cls->_stack.task;    MSKrescodee &trmcode = __cls->_stack.trmcode;    double &temp = __cls->_stack.temp;    double &S_n = __cls->_stack.S_n;    double &P_other = __cls->_stack.P_other;    double &P_i = __cls->_stack.P_i;    double &lambda = __cls->_stack.lambda;    double &proportion = __cls->_stack.proportion;    double &epsilon = __cls->_stack.epsilon;    double &diff = __cls->_stack.diff;    double *&result = __cls->_stack.result;    double &update_prob = __cls->_stack.update_prob;    unordered_map< string  ,  double > &totals = __cls->_stack.totals;    unordered_map< string  ,  double >::iterator &totals_it = __cls->_stack.totals_it;    double &total_traffic = __cls->_stack.total_traffic;    callback< void >::ref &cb = __cls->_args.cb;    use_reference (cb);    switch (__cls->jumpto ()) {   case 0: break;   case 1:     goto SubdomainInfo__calculate_optimal_routes__label_1;     break;   case 2:     goto SubdomainInfo__calculate_optimal_routes__label_2;     break;   case 3:     goto SubdomainInfo__calculate_optimal_routes__label_3;     break;   case 4:     goto SubdomainInfo__calculate_optimal_routes__label_4;     break;   case 5:     goto SubdomainInfo__calculate_optimal_routes__label_5;     break;   case 6:     goto SubdomainInfo__calculate_optimal_routes__label_6;     break;   case 7:     goto SubdomainInfo__calculate_optimal_routes__label_7;     break;   case 8:     goto SubdomainInfo__calculate_optimal_routes__label_8;     break;   default:     panic ("unexpected case.\n");     break;   }
# 611 "resolver.T"


  // Get optimization parameters
  
# 614 "resolver.T"
  do {     do {       closure_wrapper<SubdomainInfo__calculate_optimal_routes__closure_t > __cls_g (__cls_r);     __cls->init_block (1, 614);     __cls->set_jumpto (1); 
# 614 "resolver.T"
 this->get_opt_data(mkevent(sd_opt)); 
# 614 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  SubdomainInfo__calculate_optimal_routes__label_1:       ;   } while (0);
# 614 "resolver.T"


  // Get global data
  
# 617 "resolver.T"
  do {     do {       closure_wrapper<SubdomainInfo__calculate_optimal_routes__closure_t > __cls_g (__cls_r);     __cls->init_block (2, 617);     __cls->set_jumpto (2); 
# 617 "resolver.T"
 this->get_traffic_totals(sd_opt, 
   false, mkevent(totals, total_traffic)); 
# 618 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  SubdomainInfo__calculate_optimal_routes__label_2:       ;   } while (0);
# 618 "resolver.T"
  

  // Find my proportion
  
# 621 "resolver.T"
  do {     do {       closure_wrapper<SubdomainInfo__calculate_optimal_routes__closure_t > __cls_g (__cls_r);     __cls->init_block (3, 621);     __cls->set_jumpto (3); 
# 621 "resolver.T"
 this->get_my_totals(10, mkevent(unused, temp)); 
# 621 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  SubdomainInfo__calculate_optimal_routes__label_3:       ;   } while (0);
# 621 "resolver.T"

  if (debug) cout << "My total: " << temp << " Other total " << total_traffic
    << "\n";
  S_n = temp / (total_traffic + temp);
  if (debug) cout << "Using S_n " << S_n << "\n";

  S_n = 1.0;
  // Get client request data
  props = this->get_client_props(10);
  it = props.begin();
  
  if (debug) cout << "Calculating optimal policy for " << 
    this->storage.fqdn << "\n";
  num_clients = props.size();
  num_servers = this->storage.records.size();
  problem_size = num_clients * num_servers;

  // Make sure we have enough records in opt

  if (debug) {
    cout << sd_opt.records.size();
    cout << this->storage.records.size();

    cout << "Number of clients: " << num_clients;
    cout << " Number of servers: " << num_servers;
  }

  r = MSK_makeenv(&env, NULL, NULL, NULL, NULL);
  r = MSK_initenv(env);
  r = MSK_maketask(env, num_clients, problem_size, &task);
  MSK_linkfiletotaskstream(task,MSK_STREAM_LOG,"debug.txt",0);
  r = MSK_append(task, MSK_ACC_CON, num_clients);
  r = MSK_append(task, MSK_ACC_VAR, problem_size);
  r = MSK_putmaxnumvar(task, problem_size);
  r = MSK_putmaxnumcon(task, num_clients);
  r = MSK_putmaxnumanz(task, problem_size);
  
  for (i=0; i < num_servers; i++) {
    for (j=0; j < num_clients; j++) {
      for (k=0; k < num_clients; k++) {
        memcpy(&lambda, &sd_opt.records[i].lambda, sizeof(double));
        temp = props[j].second * props[k].second * lambda;
        if (j >= k) {
          r = MSK_putqobjij(task, j * num_servers + i, 
                                  k * num_servers + i, temp);
          if (r != MSK_RES_OK) { fatal << "Call returned bad" << r; }
        }
        // row: j * num_servers + i // col: k * num_servers + i
      }
    }
  }

  // Add "sum to 1" constraints
  for (i = 0; i < num_clients; i++) {
    for (j = 0; j < num_servers; j++) {
      temp_index = i;
      temp = 1.0;
      r = MSK_putavec(task, MSK_ACC_VAR, i * num_servers + j, 1, &temp_index,
        &temp );
    }
    r = MSK_putbound(task, MSK_ACC_CON, i, MSK_BK_FX, 1.0, 1.0);
  }


  // Add constraints that all x[] must be positive (may be default)
  for (i = 0; i < problem_size; i++) {
    MSK_putbound(task, MSK_ACC_VAR, i, MSK_BK_RA, 0.0, +MSK_INFINITY);
  }

  // Add linear coefficients
  for (i = 0; i < num_clients; i++) {
 
    for (j = 0; j < num_servers; j++) {
      
# 694 "resolver.T"
  do {     do {       closure_wrapper<SubdomainInfo__calculate_optimal_routes__closure_t > __cls_g (__cls_r);     __cls->init_block (4, 694);     __cls->set_jumpto (4); 
# 694 "resolver.T"
get_client_region(
        this->storage.records[j].content.cstr(), mkevent(other));
# 695 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  SubdomainInfo__calculate_optimal_routes__label_4:       ;   } while (0);
# 695 "resolver.T"

        cr = props[i].first;
      distance = ((cr.lat - other.lat) * (cr.lat - other.lat)) +
        ((cr.lon - other.lon) * (cr.lon - other.lon));
      distance_norm = (float) distance / (350 * 350);
      // Add dist(c, i) * alpha_c * S_n
      temp = distance_norm * props[i].second * S_n;
      
      totals_it = totals.find(this->storage.records[j].content.cstr());
      if (totals_it == totals.end()) {
        if (debug) cout << "No record data for " << 
         this->storage.records[j].content.cstr();
        exit(1);
      }

      P_other = totals_it->second / total_traffic;
      // Allow some FP errors
      if ((total_traffic > -.1) && (total_traffic < .1)) P_other = 0.0;

      // Add S_n * 2 * alpha_c * (P_other - w) * lambda
      memcpy(&proportion, &sd_opt.records[j].proportion, sizeof(double));
      memcpy(&lambda, &sd_opt.records[j].lambda, sizeof(double));

      if (debug) cout << "Lambda: " << lambda << " P_other: " << P_other
        << " Proportion: " << proportion << endl;
      temp+= S_n * 2 * (P_other - proportion) * lambda;
      MSK_putcj(task, i * num_servers + j, temp);
    }
  }

  r = MSK_putobjsense(task, MSK_OBJECTIVE_SENSE_MINIMIZE);

  r = MSK_optimizetrm(task, &trmcode);

  if (debug) {
    cout << "After optimization";
    if (trmcode == MSK_RES_OK) cout << "OK\n";
    else { cout << trmcode; }
  }

  MSK_solutionsummary (task, MSK_STREAM_ERR);
  MSK_getsolutionstatus (task, MSK_SOL_ITR, NULL, &solsta);
  if (solsta == MSK_SOL_STA_OPTIMAL || solsta == MSK_SOL_STA_NEAR_OPTIMAL) {
    if (debug) cout << "At optimal point\n";
  }
  else {
    if (debug) cout << "NOT Optimal ";
    if (debug) printf("%i\n", solsta);
    TRIGGER(cb);
    
# 744 "resolver.T"
  do { __cls->end_of_scope_checks (744);
# 744 "resolver.T"
    return ;  } while (0);
  }

  result = new double[problem_size];
  MSK_getsolutionslice(task, MSK_SOL_ITR, MSK_SOL_ITEM_XX, 0, problem_size,
    result);
  if (debug) {
    for (i = 0; i < problem_size; i++) {
      cout << result[i];
      cout << endl;
    }
  }
  cout << time(NULL);
  cout << ": Policy update";
  // Populate routing rules based on the new data
  for (i = 0; i < num_clients; i++) {
    client_rules = vector<pair<record, float> > ();
    cout << "(" << props[i].first.lat << ", " << props[i].first.lon << ") <";
    for (j = 0; j < num_servers; j++) {
      client_rules.push_back(pair<record, float> 
        (this->storage.records[j], result[i * num_servers + j]));
      cout << this->storage.records[j].content;
      cout << " " << result[i * num_servers + j] << " ";
    }
    cout << ">";
    new_rules.insert(pair<ClientRegion, vector<pair<record, float> > > (
      props[i].first, client_rules));
  }
  cout << endl;
  fflush(stdout);
  this->rules = new_rules;

  // Store expected traffic given this new policy
  
# 777 "resolver.T"
  do {     do {       closure_wrapper<SubdomainInfo__calculate_optimal_routes__closure_t > __cls_g (__cls_r);     __cls->init_block (5, 777);     __cls->set_jumpto (5); 
# 777 "resolver.T"
this->update_expected_traffic(10, mkevent());
# 777 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  SubdomainInfo__calculate_optimal_routes__label_5:       ;   } while (0);
# 777 "resolver.T"


  
# 779 "resolver.T"
  do {     do {       closure_wrapper<SubdomainInfo__calculate_optimal_routes__closure_t > __cls_g (__cls_r);     __cls->init_block (6, 779);     __cls->set_jumpto (6); 
# 779 "resolver.T"
 this->get_opt_data(mkevent(sd_opt)); 
# 779 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  SubdomainInfo__calculate_optimal_routes__label_6:       ;   } while (0);
# 779 "resolver.T"



  update_prob = 1.0 / craq.number_of_nodes();
  if (((double) rand() / ((double) RAND_MAX + (double) 1)) > update_prob) {
    TRIGGER(cb);
    
# 785 "resolver.T"
  do { __cls->end_of_scope_checks (785);
# 785 "resolver.T"
    return ;  } while (0);
  }

  TRIGGER(cb);
  
# 789 "resolver.T"
  do { __cls->end_of_scope_checks (789);
# 789 "resolver.T"
    return ;  } while (0);

  // Update optimization paramters

  
# 793 "resolver.T"
  do {     do {       closure_wrapper<SubdomainInfo__calculate_optimal_routes__closure_t > __cls_g (__cls_r);     __cls->init_block (7, 793);     __cls->set_jumpto (7); 
# 793 "resolver.T"
 this->get_traffic_totals(sd_opt, true, 
    mkevent(totals, total_traffic)); 
# 794 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  SubdomainInfo__calculate_optimal_routes__label_7:       ;   } while (0);
# 794 "resolver.T"


  // We can't do anything useful if there is no traffic right now
  if (total_traffic < 0.1) {
    TRIGGER(cb);
    
# 799 "resolver.T"
  do { __cls->end_of_scope_checks (799);
# 799 "resolver.T"
    return ;  } while (0);
  }
  if (debug) cout << "Total traffic: " << total_traffic;

  for (int i = 0; i < num_servers; i++) {
    totals_it = totals.find(this->storage.records[i].content.cstr());
    P_i = totals_it->second / total_traffic;

    memcpy(&proportion, &sd_opt.records[i].proportion, sizeof(double));
    memcpy(&epsilon, &sd_opt.records[i].epsilon, sizeof(double));    
    diff = ((P_i - proportion) * (P_i - proportion)) - (epsilon * epsilon);

    if (debug) {
      cout << "True proportion was " << P_i << " while requested was " <<
        proportion << endl;
      cout << " diff^2: " << (diff * diff) << " exceeded epsilon^2: " << 
        (epsilon * epsilon) << "\n";
    }

    memcpy(&lambda, &sd_opt.records[i].lambda, sizeof(double));      

    if (debug) {
      cout << "Updating lambda_i for instance " << 
        this->storage.records[i].content.cstr() << " old value " <<
        lambda << "\n";
    } 
    lambda = lambda + (1.0 / (epsilon * epsilon)) * (diff);

    if (lambda < 0.0) continue;
    if (debug) cout << "New value " << lambda << "\n";
	   
    memcpy(&sd_opt.records[i].lambda, &lambda, sizeof(double));
  }

  
# 833 "resolver.T"
  do {     do {       closure_wrapper<SubdomainInfo__calculate_optimal_routes__closure_t > __cls_g (__cls_r);     __cls->init_block (8, 833);     __cls->set_jumpto (8); 
# 833 "resolver.T"
 this->set_opt_data(sd_opt, mkevent()); 
# 833 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  SubdomainInfo__calculate_optimal_routes__label_8:       ;   } while (0);
# 833 "resolver.T"


  TRIGGER(cb);
# 836 "resolver.T"
  do {   __cls->end_of_scope_checks (836);   return;   } while (0);
# 836 "resolver.T"
}

void client_debug(callback<void>::ref cb, CLOSURE);
# 839 "resolver.T"
class client_debug__closure_t : public closure_t { public:   client_debug__closure_t ( callback< void >::ref cb) : closure_t ("resolver.T", "client_debug"),  _stack (cb), _args (cb) {}   void reenter ()   {     client_debug (_args.cb, mkref (this));   } void v_reenter () { reenter (); }   struct stack_t {     stack_t ( callback< void >::ref cb) {}      SubdomainInfo *sd;      unsigned int next_update_interval;   };   struct args_t {     args_t ( callback< void >::ref cb) : cb (cb) {}      callback< void >::ref cb;   };   stack_t _stack;   args_t _args;   bool is_onstack (const void *p) const   {     return (static_cast<const void *> (&_stack) <= p &&             static_cast<const void *> (&_stack + 1) > p);   } }; 
# 839 "resolver.T"
void 
client_debug( callback< void >::ref __tame_cb, ptr<closure_t> __cls_g)
{
# 839 "resolver.T"

  
# 840 "resolver.T"
  client_debug__closure_t *__cls;   ptr<client_debug__closure_t > __cls_r;   if (!__cls_g) {     if (tame_check_leaks ()) start_rendezvous_collection ();     __cls_r = New refcounted<client_debug__closure_t> (__tame_cb);     if (tame_check_leaks ()) __cls_r->collect_rendezvous ();     __cls = __cls_r;     __cls_g = __cls_r;   } else {     __cls =     reinterpret_cast<client_debug__closure_t *> (static_cast<closure_t *> (__cls_g));     __cls_r = mkref (__cls);   }    SubdomainInfo *&sd = __cls->_stack.sd;    unsigned int &next_update_interval = __cls->_stack.next_update_interval;    callback< void >::ref &cb = __cls->_args.cb;    use_reference (cb);    switch (__cls->jumpto ()) {   case 0: break;   case 1:     goto client_debug__label_1;     break;   case 2:     goto client_debug__label_2;     break;   default:     panic ("unexpected case.\n");     break;   }
# 843 "resolver.T"

  TRIGGER(cb);
  next_update_interval = (rand() % update_interval) + 1;
  while (true) {
    if (debug) 
      cout << "Delaying optimization " << next_update_interval << " seconds\n";
    
# 849 "resolver.T"
  do {     do {       closure_wrapper<client_debug__closure_t > __cls_g (__cls_r);     __cls->init_block (1, 849);     __cls->set_jumpto (1); 
# 849 "resolver.T"
 delaycb(next_update_interval, 0, mkevent()); 
# 849 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  client_debug__label_1:       ;   } while (0);
# 849 "resolver.T"

    subdomain_cache_it = subdomain_cache.begin();
    if (debug) cout << "Running optimization\n\n";
    while (subdomain_cache_it != subdomain_cache.end()) {
      sd = const_cast<SubdomainInfo*>(&*subdomain_cache_it);
      if (debug) cout <<  sd->storage.fqdn.cstr();
      // Calculate optimal routes based on external traffic
      
# 856 "resolver.T"
  do {     do {       closure_wrapper<client_debug__closure_t > __cls_g (__cls_r);     __cls->init_block (2, 856);     __cls->set_jumpto (2); 
# 856 "resolver.T"
 sd->calculate_optimal_routes(mkevent()); 
# 856 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  client_debug__label_2:       ;   } while (0);
# 856 "resolver.T"

      //twait {sd->update_expected_traffic(10, mkevent());}
      subdomain_cache_it++;
    }
    next_update_interval = (update_interval - next_update_interval) + 
                           (rand() % update_interval + 1);
  }
# 863 "resolver.T"
  do {   __cls->end_of_scope_checks (863);   return;   } while (0);
# 863 "resolver.T"
}


vector<pair<ClientRegion, float> > 
  SubdomainInfo::get_client_props(int minutes) {
  vector<pair<ClientRegion, unsigned int> > totals;
  vector<pair<ClientRegion, float> > out;
  unsigned int total_volume = 0;

  size_t now = time(NULL);
  client_requests_iter client_it;
  client_it = this->num_requests.begin();

  while (client_it != this->num_requests.end()) {
    unordered_map<size_t, unsigned int>* requests = client_it->second;
    num_request_iter time_it;
    time_it = requests->begin();
    unsigned int client_total = 0;
    while(time_it != requests->end()) {
      if (time_it->first > (now - (minutes * 60))) {
        client_total += time_it->second;
        total_volume += time_it->second;
      }
      time_it++;
    }
  
    totals.push_back(pair<ClientRegion, unsigned int> 
      (client_it->first, client_total));
    client_it++;
  }

  // Now all client traffic has been recorded, so go back and normalize
  vector<pair<ClientRegion, unsigned int> >::iterator totals_it =
    totals.begin();
  while (totals_it != totals.end()) {
    if (debug) {
      cout << "Adding region (" << totals_it->first.lat << ", ";
      cout << totals_it->first.lon << ") ";
      cout << "Total traffic for this region " << totals_it->second << "\n";
    }
    out.push_back(pair<ClientRegion, float> 
      (totals_it->first, (float) totals_it->second / total_volume));
    totals_it++;
  }

  return out;
}

// Return a subset of the A records for SubdomainInfo as determined
// by optimal mapping policy. If policy not yet in place, default
// policy is to return nereast three records.
# 914 "resolver.T"
static void  get_a_records( SubdomainInfo *sd,  ClientRegion *cr,  callback< void  ,  vector< record > >::ref cb, ptr<closure_t> __cls_g = NULL); 
# 914 "resolver.T"
class get_a_records__closure_t : public closure_t { public:   get_a_records__closure_t ( SubdomainInfo *sd,  ClientRegion *cr,  callback< void  ,  vector< record > >::ref cb) : closure_t ("resolver.T", "get_a_records"),  _stack (sd, cr, cb), _args (sd, cr, cb) {}   void reenter ()   {     get_a_records (_args.sd, _args.cr, _args.cb, mkref (this));   } void v_reenter () { reenter (); }   struct stack_t {     stack_t ( SubdomainInfo *sd,  ClientRegion *cr,  callback< void  ,  vector< record > >::ref cb) {}      ClientRegion other;      vector< record > out;      vector< pair< record  ,  float > > rules;      rules_iter r_it;      bool rules_present;      unordered_map< ClientRegion  ,  float  ,  ClientRegionHash  ,  ClientRegionEqual > this_rec;      vector< pair< record  ,  float > >::iterator record_it;      double cumulative;      double random;   };   struct args_t {     args_t ( SubdomainInfo *sd,  ClientRegion *cr,  callback< void  ,  vector< record > >::ref cb) : sd (sd), cr (cr), cb (cb) {}      SubdomainInfo *sd;      ClientRegion *cr;      callback< void  ,  vector< record > >::ref cb;   };   stack_t _stack;   args_t _args;   bool is_onstack (const void *p) const   {     return (static_cast<const void *> (&_stack) <= p &&             static_cast<const void *> (&_stack + 1) > p);   } }; 
# 914 "resolver.T"
void 
get_a_records( SubdomainInfo *__tame_sd,  ClientRegion *__tame_cr,  callback< void  ,  vector< record > >::ref __tame_cb, ptr<closure_t> __cls_g)
{
# 915 "resolver.T"

  
# 916 "resolver.T"
  get_a_records__closure_t *__cls;   ptr<get_a_records__closure_t > __cls_r;   if (!__cls_g) {     if (tame_check_leaks ()) start_rendezvous_collection ();     __cls_r = New refcounted<get_a_records__closure_t> (__tame_sd, __tame_cr, __tame_cb);     if (tame_check_leaks ()) __cls_r->collect_rendezvous ();     __cls = __cls_r;     __cls_g = __cls_r;   } else {     __cls =     reinterpret_cast<get_a_records__closure_t *> (static_cast<closure_t *> (__cls_g));     __cls_r = mkref (__cls);   }    ClientRegion &other = __cls->_stack.other;    vector< record > &out = __cls->_stack.out;    vector< pair< record  ,  float > > &rules = __cls->_stack.rules;    rules_iter &r_it = __cls->_stack.r_it;    bool &rules_present = __cls->_stack.rules_present;    unordered_map< ClientRegion  ,  float  ,  ClientRegionHash  ,  ClientRegionEqual > &this_rec = __cls->_stack.this_rec;    vector< pair< record  ,  float > >::iterator &record_it = __cls->_stack.record_it;    double &cumulative = __cls->_stack.cumulative;    double &random = __cls->_stack.random;    SubdomainInfo *&sd = __cls->_args.sd;    ClientRegion *&cr = __cls->_args.cr;    callback< void  ,  vector< record > >::ref &cb = __cls->_args.cb;    use_reference (sd);     use_reference (cr);     use_reference (cb);    switch (__cls->jumpto ()) {   case 0: break;   case 1:     goto get_a_records__label_1;     break;   default:     panic ("unexpected case.\n");     break;   }
# 927 "resolver.T"

  rules_present = false;
  r_it = sd->rules.find(*cr);

  if (r_it != sd->rules.end()) {
    rules_present = true;
    record_it = r_it->second.begin();
    cumulative = 0.0;
    random = (double) rand() / ((double) RAND_MAX + (double) 1);
    while (record_it != r_it->second.end()) {
      cumulative += record_it->second;
      if (cumulative > random) {
        out.push_back(record_it->first);
        TRIGGER(cb, out);
        
# 941 "resolver.T"
  do { __cls->end_of_scope_checks (941);
# 941 "resolver.T"
    return ;  } while (0);
      }
      record_it++;
    }
    // Shouldn't ever get here
  }
  
  // If we don't have rules yet, just use proximity
  
# 949 "resolver.T"
  do {     do {       closure_wrapper<get_a_records__closure_t > __cls_g (__cls_r);     __cls->init_block (1, 949);     __cls->set_jumpto (1); 
# 949 "resolver.T"
 closest_n_records(sd, cr, MAX_A_RECORDS, mkevent(out)); 
# 949 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  get_a_records__label_1:       ;   } while (0);
# 949 "resolver.T"

  TRIGGER(cb, out);
# 951 "resolver.T"
  do {   __cls->end_of_scope_checks (951);   return;   } while (0);
# 951 "resolver.T"
}

// Gets a subdomain record from cache. May hit CRAQ if cached copy is
// old or non-existent.
# 955 "resolver.T"
static void  get_from_cache( string fqdn,  cb_sub cb, ptr<closure_t> __cls_g = NULL); 
# 955 "resolver.T"
class get_from_cache__closure_t : public closure_t { public:   get_from_cache__closure_t ( string fqdn,  cb_sub cb) : closure_t ("resolver.T", "get_from_cache"),  _stack (fqdn, cb), _args (fqdn, cb) {}   void reenter ()   {     get_from_cache (_args.fqdn, _args.cb, mkref (this));   } void v_reenter () { reenter (); }   struct stack_t {     stack_t ( string fqdn,  cb_sub cb) {}      SubdomainInfo to_find;      SubdomainInfo to_insert;      str subdomain_data;      subdomain sd;   };   struct args_t {     args_t ( string fqdn,  cb_sub cb) : fqdn (fqdn), cb (cb) {}      string fqdn;      cb_sub cb;   };   stack_t _stack;   args_t _args;   bool is_onstack (const void *p) const   {     return (static_cast<const void *> (&_stack) <= p &&             static_cast<const void *> (&_stack + 1) > p);   } }; 
# 955 "resolver.T"
void 
get_from_cache( string __tame_fqdn,  cb_sub __tame_cb, ptr<closure_t> __cls_g)
{
# 955 "resolver.T"

  
# 956 "resolver.T"
  get_from_cache__closure_t *__cls;   ptr<get_from_cache__closure_t > __cls_r;   if (!__cls_g) {     if (tame_check_leaks ()) start_rendezvous_collection ();     __cls_r = New refcounted<get_from_cache__closure_t> (__tame_fqdn, __tame_cb);     if (tame_check_leaks ()) __cls_r->collect_rendezvous ();     __cls = __cls_r;     __cls_g = __cls_r;   } else {     __cls =     reinterpret_cast<get_from_cache__closure_t *> (static_cast<closure_t *> (__cls_g));     __cls_r = mkref (__cls);   }    SubdomainInfo &to_find = __cls->_stack.to_find;    SubdomainInfo &to_insert = __cls->_stack.to_insert;    str &subdomain_data = __cls->_stack.subdomain_data;    subdomain &sd = __cls->_stack.sd;    string &fqdn = __cls->_args.fqdn;    cb_sub &cb = __cls->_args.cb;    use_reference (fqdn);     use_reference (cb);    switch (__cls->jumpto ()) {   case 0: break;   case 1:     goto get_from_cache__label_1;     break;   case 2:     goto get_from_cache__label_2;     break;   default:     panic ("unexpected case.\n");     break;   }
# 961 "resolver.T"

  to_find.storage.fqdn = str(fqdn.c_str());
  if (debug) {
    cout << "Cache request for " << fqdn << endl;
    fflush(stdout);
  }
  subdomain_cache_it = subdomain_cache.find(to_find);
  
  // No data stored for this record
  if (subdomain_cache_it == subdomain_cache.end()) {
    
    if (debug) cout << "Getting key";
    fflush(stdout);
    
# 974 "resolver.T"
  do {     do {       closure_wrapper<get_from_cache__closure_t > __cls_g (__cls_r);     __cls->init_block (1, 974);     __cls->set_jumpto (1); 
# 974 "resolver.T"
craq.get_key(fqdn, mkevent(subdomain_data));
# 974 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  get_from_cache__label_1:       ;   } while (0);
# 974 "resolver.T"

    if (subdomain_data.len() < 20) {
      if (debug) cout << "CRAQ did not have data for this record\n";
      TRIGGER(cb, NULL);
      
# 978 "resolver.T"
  do { __cls->end_of_scope_checks (978);
# 978 "resolver.T"
    return ;  } while (0);
    }

    if (debug) {
      cout << "Got value of size " << subdomain_data.len();
      cout << subdomain_data;
      fflush(stdout);
    }
    str2xdr(sd, subdomain_data);

    to_insert.storage = sd;
    to_insert.validated = time(NULL);
    subdomain_cache.insert(to_insert);
    if (debug) {
      cout << "Inserting record into cache from CRAQ";
      fflush(stdout);
    }
    TRIGGER(cb, 
      const_cast<SubdomainInfo*>(&*(subdomain_cache.find(to_insert))));
    
# 997 "resolver.T"
  do { __cls->end_of_scope_checks (997);
# 997 "resolver.T"
    return ;  } while (0);
  }

  // If data stored, test if it's expired
  if (time(NULL) > (subdomain_cache_it->validated + max_cache_period)) {
    
# 1002 "resolver.T"
  do {     do {       closure_wrapper<get_from_cache__closure_t > __cls_g (__cls_r);     __cls->init_block (2, 1002);     __cls->set_jumpto (2); 
# 1002 "resolver.T"
craq.get_key(fqdn, mkevent(subdomain_data));
# 1002 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  get_from_cache__label_2:       ;   } while (0);
# 1002 "resolver.T"

    str2xdr(sd, subdomain_data);
    if (sd.seq_number > subdomain_cache_it->storage.seq_number) {
      to_insert.storage = sd;
      to_insert.validated = time(NULL);
      // Save request data from old entry
      to_insert.num_requests = subdomain_cache_it->num_requests;
      subdomain_cache.erase(subdomain_cache_it);
      subdomain_cache.insert(to_insert);
      if (debug) {
        cout << "Sequence number too low, updating record";
        cout << "New data length: " << subdomain_data.len();
        fflush(stdout);
      }
      TRIGGER(cb,
      const_cast<SubdomainInfo*>(&*(subdomain_cache.find(to_insert))));
      
# 1018 "resolver.T"
  do { __cls->end_of_scope_checks (1018);
# 1018 "resolver.T"
    return ;  } while (0);
    }
    else {
      const_cast<SubdomainInfo*>(&*subdomain_cache_it)->validated = time(NULL);
    } 
    // TODO: deal with case where sequence number not updated but TTL's are
    // different
  }

  if (debug) {
    cout << "Answering for " << fqdn << " from cache.\n";
    fflush(stdout);
  }

  // Otherwise just return the existing subdomain
  TRIGGER(cb,
    const_cast<SubdomainInfo*>(&*(subdomain_cache_it)));
# 1035 "resolver.T"
  do {   __cls->end_of_scope_checks (1035);   return;   } while (0);
# 1035 "resolver.T"
}

# 1037 "resolver.T"
static void  process( int fd, ptr<closure_t> __cls_g = NULL); 
# 1037 "resolver.T"
class process__closure_t : public closure_t { public:   process__closure_t ( int fd) : closure_t ("resolver.T", "process"),  _stack (fd), _args (fd) {}   void reenter ()   {     process (_args.fd, mkref (this));   } void v_reenter () { reenter (); }   struct stack_t {     stack_t ( int fd) {}      strbuf resp;      strbuf out;      char buff[MAX_BUFF];      int line_len;      string type;      string qname;      string coralname;      string qclass;      string qtype;      int id;      istringstream input;      string remote_ip;      string in;      string query;      string test;      Statement *stmt;      ResultSet *res;      bool init;      str subdomain_data;      SubdomainInfo *sd;      record rec;      string record_data_str;      ClientRegion cr;      vector< record > recs;   };   struct args_t {     args_t ( int fd) : fd (fd) {}      int fd;   };   stack_t _stack;   args_t _args;   bool is_onstack (const void *p) const   {     return (static_cast<const void *> (&_stack) <= p &&             static_cast<const void *> (&_stack + 1) > p);   } }; 
# 1037 "resolver.T"
void 
process( int __tame_fd, ptr<closure_t> __cls_g)
{
# 1037 "resolver.T"

  
# 1038 "resolver.T"
  process__closure_t *__cls;   ptr<process__closure_t > __cls_r;   if (!__cls_g) {     if (tame_check_leaks ()) start_rendezvous_collection ();     __cls_r = New refcounted<process__closure_t> (__tame_fd);     if (tame_check_leaks ()) __cls_r->collect_rendezvous ();     __cls = __cls_r;     __cls_g = __cls_r;   } else {     __cls =     reinterpret_cast<process__closure_t *> (static_cast<closure_t *> (__cls_g));     __cls_r = mkref (__cls);   }    strbuf &resp = __cls->_stack.resp;    strbuf &out = __cls->_stack.out;    char *buff = __cls->_stack.buff;    int &line_len = __cls->_stack.line_len;    string &type = __cls->_stack.type;    string &qname = __cls->_stack.qname;    string &coralname = __cls->_stack.coralname;    string &qclass = __cls->_stack.qclass;    string &qtype = __cls->_stack.qtype;    int &id = __cls->_stack.id;    istringstream &input = __cls->_stack.input;    string &remote_ip = __cls->_stack.remote_ip;    string &in = __cls->_stack.in;    string &query = __cls->_stack.query;    string &test = __cls->_stack.test;    Statement *&stmt = __cls->_stack.stmt;    ResultSet *&res = __cls->_stack.res;    bool &init = __cls->_stack.init;    str &subdomain_data = __cls->_stack.subdomain_data;    SubdomainInfo *&sd = __cls->_stack.sd;    record &rec = __cls->_stack.rec;    string &record_data_str = __cls->_stack.record_data_str;    ClientRegion &cr = __cls->_stack.cr;    vector< record > &recs = __cls->_stack.recs;    int &fd = __cls->_args.fd;    use_reference (fd);    switch (__cls->jumpto ()) {   case 0: break;   case 1:     goto process__label_1;     break;   case 2:     goto process__label_2;     break;   case 3:     goto process__label_3;     break;   case 4:     goto process__label_4;     break;   case 5:     goto process__label_5;     break;   default:     panic ("unexpected case.\n");     break;   }
# 1063 "resolver.T"

  while (true) {
    
# 1065 "resolver.T"
  do {     do {       closure_wrapper<process__closure_t > __cls_g (__cls_r);     __cls->init_block (1, 1065);     __cls->set_jumpto (1); 
# 1065 "resolver.T"
 tame::waitread (fd, mkevent()); 
# 1065 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  process__label_1:       ;   } while (0);
# 1065 "resolver.T"

    if ( (resp.tosuio()->input(fd)) < 0 && errno != EAGAIN) {
      break;
    }
    line_len = str(resp).len();
    if (!init) {
      test = string(str(resp).cstr());
      if (test == "HELO\t1") {
        out << "OK	DONAR Backend fired up...\n";
        init = true;
      }
      else {
        out << "FAIL\n";
      }
    }
    else {
      cout << time(NULL) << ": ";
      cout << str(resp).cstr() << " ";
      input.str(str(resp).cstr());
      input >> type;
      input >> qname;
      // Coral Hack :)
      if (qname.find("nyud.net")!=string::npos) {
        coralname = string(qname);
        qname = "nyud.net";
      }

      input >> qclass;
      input >> qtype;
      input >> id;
      input >> remote_ip;
      //out << id;
    
      
# 1098 "resolver.T"
  do {     do {       closure_wrapper<process__closure_t > __cls_g (__cls_r);     __cls->init_block (2, 1098);     __cls->set_jumpto (2); 
# 1098 "resolver.T"
get_client_region(remote_ip, mkevent(cr));
# 1098 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  process__label_2:       ;   } while (0);
# 1098 "resolver.T"

      cout << cr.lat << "," << cr.lon << endl;
      if (type == "AXFR") {
        out << strbuf("%s", last.c_str());
      }
      else {
        
# 1104 "resolver.T"
  do {     do {       closure_wrapper<process__closure_t > __cls_g (__cls_r);     __cls->init_block (3, 1104);     __cls->set_jumpto (3); 
# 1104 "resolver.T"
get_from_cache(qname, mkevent(sd));
# 1104 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  process__label_3:       ;   } while (0);
# 1104 "resolver.T"

        if (sd != NULL) {
          if (coralname.size() > 0) qname = coralname;
	  log_client_request(&cr, sd);
	  if (debug) print_request_logs(sd);

	  // Get A Records according to optimal policy
	  if (qtype == "A" || qtype == "ANY") {
	    
# 1112 "resolver.T"
  do {     do {       closure_wrapper<process__closure_t > __cls_g (__cls_r);     __cls->init_block (4, 1112);     __cls->set_jumpto (4); 
# 1112 "resolver.T"
get_a_records(sd, &cr, mkevent(recs));
# 1112 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  process__label_4:       ;   } while (0);
# 1112 "resolver.T"

	    vector<record>::iterator it = recs.begin();
	    while (it != recs.end()) {
	       out << strbuf("DATA\t%s\tIN\t%s\t%i\t-1\t%s\n",
	      qname.c_str(), it->type.cstr(),
	      it->ttl, it->content.cstr()); 
	      ++it;
	    }
	  }
	  // Add other records
	  for (int i = 0; i < sd->storage.records.size(); i++) {
	     rec = sd->storage.records[i];
	     if ((rec.type != "A") && 
	       (qtype == "ANY" || qtype == rec.type.cstr())) {
	       out << strbuf("DATA\t%s\tIN\t%s\t%i\t-1\t%s\n",
		qname.c_str(), rec.type.cstr(), 
		rec.ttl, rec.content.cstr());
	     }
	  }
	  last = string(str(out).cstr());
        }
      }
      cout << time(NULL) << ": ";
      cout << str(out).cstr();
      out << "END\n";    
    }
    
# 1138 "resolver.T"
  do {     do {       closure_wrapper<process__closure_t > __cls_g (__cls_r);     __cls->init_block (5, 1138);     __cls->set_jumpto (5); 
# 1138 "resolver.T"
 tame:: waitwrite (fd, mkevent()); 
# 1138 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  process__label_5:       ;   } while (0);
# 1138 "resolver.T"

    if ( out.tosuio()->output(fd) < 0) {
      close(fd);
      if (debug) cout << "Error writing to socket, closing";
      break;
    }
    out.tosuio()->rembytes(out.tosuio()->linelen());
    resp.tosuio()->rembytes(line_len);
    input.str("");
    input.clear();
  }
  
# 1149 "resolver.T"
  do { __cls->end_of_scope_checks (1149);
# 1149 "resolver.T"
    return ;  } while (0);
# 1150 "resolver.T"
  do {   __cls->end_of_scope_checks (1150);   return;   } while (0);
# 1150 "resolver.T"
}

# 1152 "resolver.T"
static void  listen_loop(ptr<closure_t> __cls_g = NULL); 
# 1152 "resolver.T"
class listen_loop__closure_t : public closure_t { public:   listen_loop__closure_t () : closure_t ("resolver.T", "listen_loop"),  _stack (), _args () {}   void reenter ()   {     listen_loop (mkref (this));   } void v_reenter () { reenter (); }   struct stack_t {     stack_t () : G ("resolver.T", 1155)  {}      int s;      int fd;      int len;      rendezvous_t< ev_t > G;      socklen_t t;      struct sockaddr_un local;      struct sockaddr_un remote;      char input[1000];      ev_t which;   };   struct args_t {     args_t () {}   };   stack_t _stack;   args_t _args;   bool is_onstack (const void *p) const   {     return (static_cast<const void *> (&_stack) <= p &&             static_cast<const void *> (&_stack + 1) > p);   } }; 
# 1152 "resolver.T"
void 
listen_loop(ptr<closure_t> __cls_g)
{
# 1152 "resolver.T"

  
# 1153 "resolver.T"
  listen_loop__closure_t *__cls;   ptr<listen_loop__closure_t > __cls_r;   if (!__cls_g) {     if (tame_check_leaks ()) start_rendezvous_collection ();     __cls_r = New refcounted<listen_loop__closure_t> ();     if (tame_check_leaks ()) __cls_r->collect_rendezvous ();     __cls = __cls_r;     __cls_g = __cls_r;   } else {     __cls =     reinterpret_cast<listen_loop__closure_t *> (static_cast<closure_t *> (__cls_g));     __cls_r = mkref (__cls);   }    int &s = __cls->_stack.s;    int &fd = __cls->_stack.fd;    int &len = __cls->_stack.len;    rendezvous_t< ev_t > &G = __cls->_stack.G;    socklen_t &t = __cls->_stack.t;    struct sockaddr_un &local = __cls->_stack.local;    struct sockaddr_un &remote = __cls->_stack.remote;    char *input = __cls->_stack.input;    ev_t &which = __cls->_stack.which;   switch (__cls->jumpto ()) {   case 0: break;   case 1:     goto listen_loop__label_1;     break;   default:     panic ("unexpected case.\n");     break;   }
# 1160 "resolver.T"


  if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
      perror("socket");
      exit(1);
  }

  local.sun_family = AF_UNIX;
  strcpy(local.sun_path, sock_path);
  remove(local.sun_path);
  len = strlen(local.sun_path) + sizeof(local.sun_family);
  if (bind(s, (struct sockaddr *)&local, len) == -1) {
      perror("bind");
      exit(1);
  }

  if (listen(s, 5) == -1) {
      perror("listen");
      exit(1);
  }

  while (true) {
      tame::waitread(s, mkevent(G, READ));
      int n;
      if (debug) cout << "Waiting for a connection...\n";
      
# 1185 "resolver.T"
listen_loop__label_1: do {   if (!(G)._ti_next_trigger (which)) {     __cls->set_jumpto (1);       (G)._ti_set_join_cls (__cls_r);       return;   } else {     (G)._ti_clear_join_method ();   } } while (0);
# 1185 "resolver.T"


      switch (which) {
        case READ:
          t = sizeof(remote);
          if ((fd = accept(s, reinterpret_cast<sockaddr *>(&remote), &t)) 
             == -1) {
	    perror("accept");
	    exit(1);
          }
          if (debug) cout << "Connected.\n";
          process(fd);
          break;
	default:
          break;
      }
  }
  
# 1202 "resolver.T"
  do { __cls->end_of_scope_checks (1202);
# 1202 "resolver.T"
    return ;  } while (0);
# 1203 "resolver.T"
  do {   __cls->end_of_scope_checks (1203);   return;   } while (0);
# 1203 "resolver.T"
}

# 1205 "resolver.T"
static void  main2( int argc,  char  * *argv, ptr<closure_t> __cls_g = NULL); 
# 1205 "resolver.T"
class main2__closure_t : public closure_t { public:   main2__closure_t ( int argc,  char  * *argv) : closure_t ("resolver.T", "main2"),  _stack (argc, argv), _args (argc, argv) {}   void reenter ()   {     main2 (_args.argc, _args.argv, mkref (this));   } void v_reenter () { reenter (); }   struct stack_t {     stack_t ( int argc,  char  * *argv) : pa ("donar.conf", -1)  {}      Driver *driver;      Statement *quova_stmt;      bool init_success;      int log_clean_interval;      conftab ct;      int ch;      str config;      vec< str > av;      int line;      bool errors;      parseargs pa;      struct in_addr addr;      strbuf mosek_buf;   };   struct args_t {     args_t ( int argc,  char  * *argv) : argc (argc), argv (argv) {}      int argc;      char  * *argv;   };   stack_t _stack;   args_t _args;   bool is_onstack (const void *p) const   {     return (static_cast<const void *> (&_stack) <= p &&             static_cast<const void *> (&_stack + 1) > p);   } }; 
# 1205 "resolver.T"
void 
main2( int __tame_argc,  char  * *__tame_argv, ptr<closure_t> __cls_g)
{
# 1205 "resolver.T"

  
# 1206 "resolver.T"
  main2__closure_t *__cls;   ptr<main2__closure_t > __cls_r;   if (!__cls_g) {     if (tame_check_leaks ()) start_rendezvous_collection ();     __cls_r = New refcounted<main2__closure_t> (__tame_argc, __tame_argv);     if (tame_check_leaks ()) __cls_r->collect_rendezvous ();     __cls = __cls_r;     __cls_g = __cls_r;   } else {     __cls =     reinterpret_cast<main2__closure_t *> (static_cast<closure_t *> (__cls_g));     __cls_r = mkref (__cls);   }    Driver *&driver = __cls->_stack.driver;    Statement *&quova_stmt = __cls->_stack.quova_stmt;    bool &init_success = __cls->_stack.init_success;    int &log_clean_interval = __cls->_stack.log_clean_interval;    conftab &ct = __cls->_stack.ct;    int &ch = __cls->_stack.ch;    str &config = __cls->_stack.config;    vec< str > &av = __cls->_stack.av;    int &line = __cls->_stack.line;    bool &errors = __cls->_stack.errors;    parseargs &pa = __cls->_stack.pa;    struct in_addr &addr = __cls->_stack.addr;    strbuf &mosek_buf = __cls->_stack.mosek_buf;    int &argc = __cls->_args.argc;    char  * *&argv = __cls->_args.argv;    use_reference (argc);     use_reference (argv);    switch (__cls->jumpto ()) {   case 0: break;   case 1:     goto main2__label_1;     break;   case 2:     goto main2__label_2;     break;   default:     panic ("unexpected case.\n");     break;   }
# 1220 "resolver.T"

  /*
  while ((ch = getopt(argc, argv, "C")) != -1) {
    switch(ch) {
      case 'C':
        config = optarg;
        break;
    }
  }
  */
  // Config options
  ct.add("MySqlUser", &mysql_user);
  ct.add("MySqlPass", &mysql_pass);
  ct.add("MySqlHost", &mysql_host);
  ct.add("ZooList", &zoo_list);
  ct.add("SockPath", &sock_path);
  ct.add("MosekKeyFile", &mosek_file);
  ct.insert(New conftab_bool ("ShowDebug", &debug, true));
  ct.insert(New conftab_int<unsigned int>
      ("MaxCacheSeconds", &max_cache_period, 0, 300, 10));
  ct.insert(New conftab_int<unsigned int>
      ("UpdateInterval", &update_interval, 0, 10000, 500));

  line = 0;
  while (pa.getline(&av, &line)) {
    if (!ct.match(av, str("donar.conf"), line, &errors)) {
      warn << config << ":" << line << ": unknown directive\n";
    }
  }
  // Open log file
  logfile.open("/var/log/donar", ios::out | ios::app);
  logfile << "DONAR LOG\n";

/* NOT WORKING RIGHT NOW
  // Set mosek env variable
  mosek_buf << "MOSEKLM_LICENSE_FILE=";
  mosek_buf << mosek_file;
  putenv((char*) str(mosek_buf).cstr());
*/

  // Setup mysql connections
  driver = get_driver_instance();
  
  quova_conn = driver->connect(mysql_host.cstr(), mysql_user.cstr(), 
    mysql_pass.cstr());
  donar_conn = driver->connect(mysql_host.cstr(), mysql_user.cstr(), 
    mysql_pass.cstr());  

  quova_stmt = quova_conn->createStatement();
  quova_stmt->execute("USE quova");

  // Periodically clean old data
  delaycb(LOG_CLEAN_INTERVAL_MINS * 60, 0, wrap(clean_request_logs));

  // Temporary debug
  
# 1275 "resolver.T"
  do {     do {       closure_wrapper<main2__closure_t > __cls_g (__cls_r);     __cls->init_block (1, 1275);     __cls->set_jumpto (1); 
# 1275 "resolver.T"
 client_debug(mkevent()); 
# 1275 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  main2__label_1:       ;   } while (0);
# 1275 "resolver.T"


  // Setup craq connection
  
# 1278 "resolver.T"
  do {     do {       closure_wrapper<main2__closure_t > __cls_g (__cls_r);     __cls->init_block (2, 1278);     __cls->set_jumpto (2); 
# 1278 "resolver.T"

    craq.init(string(zoo_list.cstr()), mkevent(init_success));
  
# 1280 "resolver.T"
      if (!__cls->block_dec_count (__FL__))       return;     } while (0);  main2__label_2:       ;   } while (0);
# 1280 "resolver.T"

  logfile << "Using IP Address: " << craq.my_ip_addr.c_str();
  inet_aton(craq.my_ip_addr.c_str(), &addr);
  my_ip_addr = (unsigned int) addr.s_addr;

  if (init_success) {
    if (debug) cout << "Connection established.\n";
  }
  else {
    if (debug) cout << "Connection establishemnt failed.\n";
    exit(-1);
  }
  
  listen_loop();
# 1294 "resolver.T"
  do {   __cls->end_of_scope_checks (1294);   return;   } while (0);
# 1294 "resolver.T"
}

int main (int argc, char* argv[]) {
  main2(argc, argv);
  amain();
}
